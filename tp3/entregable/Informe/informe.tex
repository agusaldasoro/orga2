\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
%\usepackage{makeidx}
\usepackage{paralist} %itemize inline

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}


\input{codesnippet}
\input{page.layout}
% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}


% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %



\begin{document}


\thispagestyle{empty}
\materia{Organización del Computador II}
\submateria{Segundo Cuatrimestre de 2014}
\titulo{Trabajo Práctico III}
\subtitulo{System Programming - Zombi defense}
\integrante{Aldasoro Agustina}{86/13}{agusaldasoro@gmail.com}
\integrante{Rey Maximiliano}{37/13}{rey.maximiliano@gmail.com}
\integrante{Tirabasso Ignacio}{718/12}{ignacio.tirabasso@gmail.com}

 


\maketitle
\newpage

%\thispagestyle{empty}
%\vfill
%\begin{abstract}
%En el presente trabajo se describe la problemática de ...
%\end{abstract}

%\thispagestyle{empty}
%\vspace{3cm}
%\tableofcontents
\newpage


%\normalsize
\newpage
\section{Ejercicio 1}
{\large a)} \underline{Tabla de descriptores de la GDT.} \\

Al momento de armar la GDT, acorde a lo dispuesto en el enunciado, dejamos las primeras siete entradas de la tabla de descriptores libres. Luego, a partir de la posici\'on 8 dejamos los descriptores de segmento pedidos: c\'odigo y datos nivel 0 y c\'odigo y datos nivel 3.

Armamos los cuatro segmentos de la GDT, llam\'andolos: 
\begin{codesnippet}
\begin{verbatim}
    [GDT_IDX_DATA_0] = (gdt_entry) ;  
    [GDT_IDX_DATA_3] = (gdt_entry) ; 
    [GDT_IDX_CODE_0] = (gdt_entry) ; 
    [GDT_IDX_CODE_3] = (gdt_entry) ; 
\end{verbatim}
\end{codesnippet}

A los cuatro les seteamos el mismo \emph{l\'imite}: \textbf{0x26EFF} y la misma \emph{base} en \textbf{0}, de este modo los cuatro descriptores de segmento direccionan a los primeros \emph{623MB} de memoria. El \emph{segment type} var\'ia depende el segmento: CODE_0: \textbf{0x0A} (code execute/read), CODE_3: \textbf{0x0F} (code execute/read, conforming, accesed), DATA_0 y DATA_3: \textbf{0x02} (data read/write). El \emph{Descriptor type} va en todos para system, por lo tanto es \textbf{0}. El \emph{Descriptor privilege level} coincide con el nombre del descriptor (\textbf{0} para CODE_0 y DATA_0; \textbf{3} para CODE_3 y DATA_3). El bit de \emph{Present} va para todos en \textbf{1} y los bit de \emph{Available for use by system software} y \emph{l} van para todos en \textbf{0}. El bit de \emph{Default operation size} va para todos en \textbf{1} porque es un c\'odigo de 32bits. El bit de \emph{Granularity} va para todos en \textbf{1}.\\
    


{\large b)} \underline{Pasaje a modo protegido y seteo de la pila del kernel.}\\

Para pasar a modo protegido los pasos que debemos llevar a cabo son:


\begin{itemize}
\item[$\triangleright$] Completar la GDT (resuelto en el inciso A).
\item[$\triangleright$] Deshabilitar interrupciones (para ello se ejecuta la instrucci\'on \emph{cli}).
\item[$\triangleright$] Habilitar A20 (en nuestro caso se resuelve haciendo \emph{call habilitar_A20}).
\item[$\triangleright$] Cargar el registro GDTR con la direcci\'on base de la GDT (lo hacemos con la instrucci\'on  \\ \emph{lgdt} \emph{ [GDT_DESC]} la etiqueta GDT_DESC apunta al descriptor de la GDT en el c\'odigo).
\item[$\triangleright$] Una vez hecho esto, estamos en condiciones de setear el bit PE del registro CR0 (debemos hacer: \emph{mov eax,cr0 ; or eax,1 ; mov cr0,eax}).
\item[$\triangleright$] Lo siguiente a realizar es el \emph{jump far} a la siguiente instrucci\'on (utilizamos el selector de segmento \emph{0x50} y de offset la etiqueta \emph{modo_protegido} \textcolor{red}{por que el selector es 0x50??}).
\item[$\triangleright$] Una vez ya en modo protegido, nos encontramos trabajando en 32 bits y ahora es cuando cargamos los registros de segmento (a los registros  \emph{es, ds, ss y gs} les asignamos el valor de \emph{0x40} y al registro \emph{fs} le asignamos el valor \emph{0x60} \textcolor{red}{aca habr\'ia que poner el porque de estos valores??}).
\end{itemize}
 \bigskip	
Para setear la pila del kernel en la direcci\'on 0x27000 debemos llevar a cabo la siguiente instrucci\'on: 
\begin{codesnippet}
\begin{verbatim}
    mov ebp, 0x27000
\end{verbatim}
\end{codesnippet}

{\large c)} \underline{Segmento adicional que describe el \'area de la pantalla en memoria que puede ser utilizado} \\ \underline{s\'olo por el kernel.}
\\
\textcolor{red}{HELP! aca no se que ponerrrrrrrr}

\begin{codesnippet}
\begin{verbatim}
    ; Cambiar modo de video a 80 X 50
    mov ax, 0003h
    int 10h ; set mode 03h
    xor bx, bx
    mov ax, 1112h
    int 10h ; load 8x8 font
\end{verbatim}
\end{codesnippet}


{\large d)} \underline{Rutina que se encarga de limpiar la pantalla y pintar el \'area del mapa}
\\

En este punto debemos establecer un fondo de color verde, junto con las dos barras laterales para cada uno de los jugadores (una roja y otra azul). Para esto, debemos contar con una funci\'on que limpie la pantalla en un primer momento: \emph{clear_screen}.\\

La funci\'on \textbf{\textit{clear_screen}}, implementada en lenguaje C, se va a encargar de: 

\begin{itemize}
\item[$\triangleright$] Guardar en una variable local: \emph{size} el tama\~no de la pantalla (VIDEO_COLS * VIDEO_FILS).
\item[$\triangleright$] Luego va a hacer un while desde \emph{0} hasta \emph{size} que, empezando por la direcci\'on donde est\'a almacenada la memoria de video, vaya guardando el caracter que es todo negro.
\end{itemize}

De este  modo, logramos hacer que toda el \'area de la pantalla quede ``pintada'' de negro. \\

\bigskip

En segunda instancia, armamos la funci\'on \emph{print_map}. La funci\'on \textbf{\textit{print_map}}, tambi\'en implementada en lenguaje C, con el fin de pintar el \'area del mapa con los colores deseados, posee el siguiente comportamiento:

\begin{itemize}
\item[$\triangleright$] En un primer momento, llama a la funci\'on \emph{clear_screen}.
\item[$\triangleright$] Se arman cuatro variables locales: blue, red, green y black. Cada una de ellas es un caracter completamente de su color.
\item[$\triangleright$] Mediante dos \textit{fors} anidados recorremos toda el \'area del mapa, y dependiendo de la posici\'on en la que se encuentre es el color que le va a ser asignado (rojo a las primeras dos columnas de la izquierda, azul a las \'ultimas dos, negro a las \'ultimas cinco filas y el resto en verde).
\end{itemize}

Luego este c\'odigo fue complejizado para que pueda imprimir los puntos de los jugadores y sus respectivos puntajes por zombie tal cual debe ser cuando comienza el juego.

\newpage
\section{Ejercicio 2}
{\large a)} \underline{Entradas en la IDT.}\\

Inicializamos las entradas 0-19 en la IDT (todas con privilegio 0). Creamos un arreglo de strings, que contenga los nombres de cada excepci\'on para luego mostrarlo en pantalla como se ve a continuaci\'on:

\begin{codesnippet}
\begin{verbatim}
static char *exceptions[] = {
    "Division by zero",
    "Debugger",
    "NMI",
    "Breakpoint",
    "Overflow",
    "Bounds",
    "Invalid Opcode",
    "Coprocessor not available",
    "Double fault",
    "Coprocessor Segment Overrun (386 or earlier only)",
    "Invalid Task State Segment",
    "Segment not present",
    "Stack Fault",
    "General protection fault",
    "Page fault",
    "reserved",
    "Math Fault",
    "Alignment Check",
    "Machine Check",
    "SIMD Floating-Point Exception"
};
\end{verbatim}
\end{codesnippet}

El c\'odigo de cada rutina de excepci\'on lo que va a hacer es:

Guardar en memoria el estado de los registros de la tss actual para luego pushearlos y llamar a la funci\'on \emph{print_exception}. Esta funci\'on va a estar encargada de imprimir el nombre del problema que se produjo, conjunto a todos estos registros que nos hab\'iamos almacenado. \\
\bigskip

{\large b)} \underline{Prueba de lo armado en el punto A.}\\

Para que el procesador utilice la IDT creada anteriormente, generamos la excepci\'on ``Divisi\'on por cero'' para probarla:

\begin{codesnippet}
\begin{verbatim}
    ; Inicializar la IDT
    call idt_inicializar
    ; Cargar IDT
    lidt [IDT_DESC]

    ; test para que salte la divide by 0 exception (0)
    mov edx,0
    mov ecx,0
    mov eax,3
    div ecx
\end{verbatim}
\end{codesnippet}

Efectivamente, anduvo acorde a lo esperado.
\newpage
\section{Ejercicio 3}
\textcolor{red}{Limpiar el buffer de video es hacer clear_screen???... Asumo que s\'i.}\\


{\large a)} \underline{Implementaci\'on completa de print_map.} \\

En el ejercicio 1 ya hab\'iamos logrado armar \textbf{clear_screen} y \textbf{print_map}, esta \'ultima contaba con una funcionalidad acotada. S\'olo armaba cuatro bloques de colores. Ahora lo que vamos a hacer es extender la funci\'on \textbf{print_map} para que escriba los puntos de los jugadores y marque el estado de los zombies, tal como aparece en la \textit{figura 9} del enunciado.\\


La funci\'on print_map la vamos a extender sum\'andole las siguientes instrucciones:

\begin{itemize}
\item[$\triangleright$] Debemos armar los \emph{cuadrados de puntaje} para el jugador rojo y para el jugador azul. Nos movemos entre las \'ultimas cinco filas, desde la columna 35 hasta la 39 se pintan con el caracter completamente rojo y desde la columna 40 hasta la 44 se pintan con el caracter completamente azul.
\item[$\triangleright$] Escribimos en el centro de cada cuadrado el puntaje inicial: 0. Para ello creamos dos caracteres que sean 0 y cada uno con los atributos necesarios para que sean: fondo rojo, letra blanca y fondo azul, letra blanca.
\item[$\triangleright$] Luego escribimos la cantidad de zombies restantes, para lo cual se utilizan dos caracteres id\'enticos a los mencionados arriba. Estos puntajes se ubican cada uno a un costado de su cuadrado respectivo.
\item[$\triangleright$] Por \'ultimo, resta escribir el estado de los zombies. Generamos un char* que sean todos los n\'umeros de zombies y d\'andole formato de fondo negro, caracter blanco los copiamos dos veces: uno para el jugador azul y otro para el jugador rojo. Como todos los zombies se encuentran disponibles, generamos otro char* que sean diez `x' y ubicamos en su posici\'on correspondiente uno que posea los atributos de fondo negro, caracter azul y otro de fondo negro, caracter rojo.
\end{itemize}

Con el objetivo de hacer que lo descripto anteriormente sea una tarea m\'as simple contamos con las funciones: \emph{print_string} y \emph{get_format}.\\

La funci\'on \textbf{print_string} recibe una posici\'on en el mapa (x,y), un char* con el texto que queremos imprimir en pantalla y un short con los atributos deseados. \textcolor{red}{PONER ALGO DE AVOID PRINT BUG}. Dentro de un \textit{for} que recorre horizontalmente la posici\'on en memoria a partir de la posici\'on (x,y), se va avanzando el char* y en cada iteraci\'on se le asigna a esa posici\'on de memoria el char actual con los atributos pasados por par\'ametro.\\
%    // avoid black print bug
%    unsigned char a = (unsigned char) attr;
%    if (a == 0) {
%        a = getFormat(C_FG_WHITE, 0, C_BG_BLACK, 0);
%    }

La funci\'on \textbf{get_format} es una funci\'on simple la cual recibe como par\'ametro los atributos deseados y los devuelve con el formato de un s\'olo char, que es el que debemos utilizar.
\begin{codesnippet}
\begin{verbatim}
unsigned char getFormat(unsigned char fore_color, char fore_bright, unsigned char back_color, 
                        char blink) {
    return fore_color | fore_bright | back_color | blink; 
}
\end{verbatim}
\end{codesnippet}


{\large b)} \underline{Rutinas encargadas de inicializar el directorio y tablas de p\'aginas para el kernel.}\\

Para poder mapear las direcciones 0x00000000 a 0x003FFFFF es necesaria una sola entrada en el Page Directory. En un primer momento, se crea un puntero a Page Directory en la direcci\'on 0x27000. Se limpian las 1024 entradas del Page Directory poniendo todos sus bits en 0.\\

Luego, a la primera entrada del Page Directory (\'indice: 0) se le asigna como base 0x28. Se le asigna permiso de escritura y lectura con su bit de presente seteado, como es de Kernel es de nivel 0.\\

Para que todo esto funcione y el primer \'indice del Page Directory apunte a un Page Table v\'alido, se debe crear un Page Table en la posici\'on 0x28000 en memoria. En esta misma se completan todos los \'indices (ya que es lo que ocupa el rango pedido para el Kernel) direccion\'andolos desde la posici\'on 0x0 en memoria, aumentando en uno acorde aumenta el \'indice. Todos tienen permiso de escritura con el bit de presente seteado, como es de Kernel es de nivel 0.\\



{\large c)} \underline{C\'odigo necesario para activar paginaci\'on.}\\

Como ya contamos con un directorio de p\'aginas y una tabla de p\'aginas estamos en condiciones de activar paginaci\'on.\\


Como para esto debemos poner en cr3 la base del directorio de p\'aginas y limpiar los bits PCD y PWT del mismo, basta con asignarle a cr3 el valor de 0x27000. De este modo la base queda en 0x27 y los bits limpios. \textcolor{red}{Es correcto esto?}\\

Por \'ultimo resta setear el bit PG del cr0, lo hacemos mediante un or.

\newpage
\section{Ejercicio 4}
{\large a)} \underline{Administraci\'on de la memoria en el \'area libre.}\\

Como conocemos las limitaciones de memoria que se poseen y acorde el contexto de uso, nunca vamos a pedir m\'as p\'aginas de las existentes porque antes terminar\'ia el juego. Por este motivo, implementamos un contador llamado \textit{p\'aginas} que denota la cantidad de p\'aginas utilizadas de modo que administra la memoria en el \'area libre.\\

Luego contamos con las funciones \textit{get_page_directory} y \textit{get_page_table} las cuales nos brindan un nuevo page directory o una nueva page table correspondientemente. Ambas se basan en esta variable que poseemos. \\

La funci\'on \textbf{get_page_directory} toma la variable global \textit{p\'aginas} y la multiplica por 4096 (el tama\~no) y se lo suma a la direcci\'on PAGES (que es 0x100000), siendo el n\'umero obtenido el puntero al nuevo Page Directory. Se inicializa en 0 cada \'indice de los 1024 que son y luego a la primer posici\'on se le da como base 0x28, se le da permiso de lectura/escritura y se setea el bit de presente \textcolor{red}{(por que hacemos esto con la primer posicion?)}. Por \'ultimo se incrementa en uno el contador de p\'aginas.\\

La funci\'on \textbf{get_page_table} tiene un comportamiento similar: adquiere el puntero a la nueva p\'agina de la misma manera, inicializa en cero sus 1024 entradas y por \'ultimo incrementa en uno el contador de \textit{p\'aginas}.\\


Es decir, a partir de la direcci\'on 0x100000 se arman todos los Page Directories y Page Tables.\\



La funci\'on \textbf{inicializar_mmu} tiene un comportamiento simple: llama a la funci\'on \\ \textit{mmu_inicializar_dir_kernel()} y luego pone en cero el contador\textit{ p\'aginas}.\\

\bigskip

{\large b)} \underline{mmu_inicializar_dir_zombi}\\

La rutina \textit{mmu_inicializar_dir_zombi} se encarga de inicializar un directorio
de p\'aginas y tablas de p\'aginas para una tarea, respetando la figura 6. Copia
el c\'odigo de la tarea a su \'area asignada, es decir la posici\'on indicada por el jugador dentro
del mapa y mapea dichas p\'aginas a partir de la direcci\'on virtual 0x08000000(128MB).\\

La funci\'on \textbf{mmu_inicializar_dir_zombie} recibe como par\'ametro el jugador (si es A o B), la clase y su posici\'on en el eje de las \emph{y}. 

\begin{itemize}
\item[$\triangleright$] Va a pedir un nuevo Page Directory mediante la funci\'on explicada anteriormente: \textit{get_page_directory}.
\item[$\triangleright$] El valor de x va a ser ANCHO_MAPA-2 si el jugador es B, 1 si el jugador es A.
\item[$\triangleright$] Luego de eso, se mapean las nueve p\'aginas correspondientes utilizando mmu_mapear_pagina y como funci\'on auxiliar get_physical_address. Esta \'ultima nos permite pasarle un (x,y) en el mapa y nos da la direcci\'on f\'isica del mismo.
\item[$\triangleright$] Consecuentemente, copiamos el c\'odigo en la p\'agina central.
\item[$\triangleright$] Devolvemos el pd creado.
\end{itemize}



\bigskip

{\large c)} \underline{Mapear y Des-Mapear p\'agina.}\\

 La rutina \textit{mmu_mapear_p\'agina} permite armar toda la estructura necesaria para que, dada una direcci\'on virtual, un puntero a Page Directory, una direcci\'on f\'isica y los atributos deseados (lectura/escritura y nivel); se mapee la direcci\'on virtual a la f\'isica.\\
 
El comportamiento de la funci\'on \textbf{mmu_mapear_p\'agina} consiste en :

\begin{itemize}
\item[$\triangleright$] Obtener el offset del Page_directory (\textit{directory}) shifteando a la derecha 22 bits la direcci\'on virtual pasada por par\'ametro.
\item[$\triangleright$] Obtener el offset del Page_table (\textit{table}) shifteando a la derecha 12 bits la direcci\'on virtual pasada por par\'ametro luego de haberle hecho un \emph{and} con 0x003FF000 as\'i obtengo s\'olo los bits de inter\'es.
\item[$\triangleright$] Si el \'indice \textit{directory} del Page Directory tiene el bit presente = 0, entonces debemos setear la base obteniendo una nueva Page Table (con la funci\'on get_page_table), d\'andole permismos de escritura y nivel acorde a lo pasado por par\'ametro y seteando el bit de presente.
\item[$\triangleright$] Obtener el puntero a la Page Table (\textit{pt}), accediendo al \'indice \textit{directory} del Page Directory pasado por par\'ametro, lo shifteamos a la izquierda 12 bits as\'i tenemos la direcci\'on de la p\'agina donde se encuentra la Page Table.
\item[$\triangleright$] En el \'indice \textit{table} de la Page Table apuntada por \textit{pt} le asignamos la direcci\'on f\'isica pasada por par\'ametro shifteada a la derecha 12 bits, asign\'andole permisos de lectura/escritura acorde y nivel a lo pasado por par\'ametro y seteando el bit de presente.
\item[$\triangleright$] Por \'ultimo, ejecutamos \emph{tlbflush} para que se invalide la cache de traducci\'on de direcciones.
\end{itemize}

\bigskip

A veces, vamos a necesitar des-mapear una p\'agina para que, bajo el cr3 actual, no se tenga m\'as permiso de acceso a la misma. Por este motivo, contamos con la funci\'on \textit{mmu_unmapear_pagina}.\\


La funci\'on \textbf{mmu_unmapear_pagina} va a recibir como par\'ametro una direcci\'on virtual y el cr3 actual. El comportamiento de esta funci\'on, si el bit de presente del Page Directory al que apunta al cr3 est\'a seteado, va a consistir en el simple acceso al Page Directory apuntado por el cr3, accediendo al \'indice descripto en la direcci\'on virtual pasada por par\'ametro. Luego dirigirse al Page Table apuntado por este, accediendo al \'indice que se encuentra en la direcci\'on virtual y una vez ah\'i limpiar el bit de presente. En otro caso, no es necesario tomar ninguna acci\'on.

\newpage
\section{Ejercicio 5}

{\large a)} \underline{Entradas necesarias en la IDT.}\\

Completamos las entradas necesarias en la IDT para asociar una rutina a la interrupci\'on del
reloj, otra a la interrupci\'on de teclado y por \'ultimo una a la interrupci\'on de software 0x66. Es decir las posiciones 32, 33 y 102.

Las primeras dos van a ser de privilegio 0 y la \'ultima de privilegio 3, asign\'andoselo mediante sus atributos.\\

\bigskip

{\large b)} \underline{Rutina asociada a la interrupci\'on de reloj.}\\

La rutina asociada a la interrupci\'on del reloj por cada tick llama a la funci\'on \textit{pr\'oximo_reloj}. La misma se encarga de mostrar cada vez que se llame, la animaci\'on de un cursor rotando en la esquina inferior derecha de la pantalla. \\

Su funcionamiento consiste en pushear los registros, llamar a \textit{proximo_reloj} que se encarga de cambiar el caracter en pantalla y a proximo_indice el cual indica qu\'e \'indice en la \emph{GDT} es el pr\'oximo a ejecutar. Si debemos cambiar de \emph{tss}, realiza el \textit{jump far}, sino termina. En ambos casos, llama previamente a \\
\textit{fin_intr_pic1} y luego hace \textit{popad} de los registros y vuelve con un \textit{iret}.\\
\bigskip

{\large c)} \underline{Rutina asociada a la interrupci\'on de teclado.}\\

La rutina asociada a la interrupci\'on de teclado fue programada en esta instancia de forma que si se presiona cualquiera de las teclas a utilizar en el juego, se presenta la misma en la esquina superior derecha de la pantalla. \\

El comportamiento de este handler consiste en testear qu\'e tecla fue presionada (mediante \textit{in \textbf{al}, 0x60}), llamar a la funci\'on handle_keyboard_interrumption que recibe como par\'ametro \textbf{eax}. Esta funci\'on se encarga de imprimir en pantalla el char que corresponda a la tecla presionada. Luego el handler llama a \textit{fin_intr_pic1} y termina la ejecuci\'on un \textit{iret}. \\
\bigskip

{\large d)} \underline{Rutina asociada a la interrupci\'on 0x66.}\\


Escribimos la rutina asociada a la interrupci\'on 0x66 para que modifique el valor de eax por
0x42, retornando con un \textit{iret}. 

\newpage
\section{Ejercicio 6}
{\large a)} \underline{Entradas en la GDT usadas como descriptores de TSS.}\\

Definimos cuatro entradas en la GDT que consideramos necesarias para ser usadas como descriptores
de TSS: una para ser utilizada por la tarea inicial, una para la tarea Idle, otra para la tarea actual y una \'ultima para la tarea siguiente.\\

Cada una de ellas se encuentra en los siguientes \'indices: 
\begin{codesnippet}
\begin{verbatim}
#define GDT_INITIAL_TSS        0xD
#define GDT_CURRENT_TSS        0xE
#define GDT_NEXT_TSS           0xF
#define GDT_TSS_IDLE           0x10
\end{verbatim}
\end{codesnippet}
\bigskip



{\large b)} \underline{Entrada de la TSS de la tarea Idle.}\\

Completamos la entrada de la TSS de la tarea Idle con la informaci\'on de la tarea Idle. La tarea Idle se encuentra en la direcci\'on 0x00016000. La pila se aloja en la misma direcci\'on que la pila del kernel y es mapeada con identity mapping. Esta tarea ocupa 1 pagina de 4KB y est\'a mapeada con identity mapping. Adem\'as la misma comparte el mismo CR3 que el kernel. \\

Se le asigna de base 0xFFFFFFFF \textcolor{red}{POR QUE???????}. Al \textbf{eip} se le asigna el valor de 0x00016000, al \textbf{cr3} se le asigna el cr3 del kernel. Como la pila se setea en la posici\'on 0x27000 se les adjudica a \textbf{ebp} y \textbf{esp} ese valor. Los registros \textbf{es}, \textbf{ds}, \textbf{ss} y \textbf{gs} se les da el valor de 0x40 mientras que al \textbf{cs} el de 0x50 \textcolor{red}{Aca habria que explicar porque, no??}. Los \textbf{eflags} se ponen en 0x202 \textcolor{red}{as\'i quedan habilitadas las interrupciones (es por eso?)}. Y por \'ultimo se le asigna a \textbf{esp0} tambi\'en 0x27000 y a \textbf{ss0} 0x40.\\
\bigskip

{\large c)} \underline{Completar una TSS libre con una tarea (Zombie).}\\

\textcolor{red}{Construir una funci\'on que complete una TSS libre con los datos correspondientes a una
tarea (zombi). El c\'odigo de las tareas se encuentra a partir de la direcci\'on 0x00010000
ocupando una pagina de 4kb cada una seg\'un indica la figura 1. Para la direcci\'on de la
pila se debe utilizar el mismo espacio de la tarea, la misma crecer\'a desde la base de la tarea. 
Para el mapa de memoria se debe construir uno nuevo utilizando la funci\'on mmu inicializar dir zombi. 
Adem\'as, tener en cuenta que cada tarea utilizar\'a una pila distinta de nivel 0, para esto se debe pedir una nueva pagina libre a tal fin.} \\
\bigskip


{\large d)} \underline{Primera ejecuci\'on de la Tarea Idle.}\\

El c\'odigo necesario para saltar a la tarea Idle desde la ejecuci\'on de la tarea inicial se realiza con un salto cambiando las tss. \textcolor{red}{Es llevado a cabo con el siguiente c\'odigo?.}\\

\begin{codesnippet}
\begin{verbatim}
jmp 0x80:0
\end{verbatim}
\end{codesnippet}



\newpage
\section{Ejercicio 7}


{\large a)} \underline{Inicializar las estructuras de datos del scheduler.}\\

\textcolor{red}{Completar.}\\
\bigskip

{\large b)} \underline{Implementaci\'on pr\'oximo \'indice.}\\
%Crear la funci\'on sched pr\'oximo indice() que devuelve el \'indice en la GDT de la pr\'oxima
%tarea a ser ejecutada. Construir la rutina de forma devuelva una tarea de cada jugador
%por vez seg\'un se explica en la secci\'on 3.2\\

\textcolor{red}{Completar.}\\
\bigskip

{\large c)} \underline{Rutina de atenci\'on a la interrupci\'on 0x66.}\\


\textcolor{red}{Completar.}\\
\bigskip

{\large d)} \underline{Rutina de atenci\'on a la interrupci\'on del Clock.}\\
%Modificar el c\'odigo necesario para que se realice el intercambio de tareas por cada ciclo de
%reloj. El intercambio se realizar\'a seg\'un indique la funci\'on sched proximo \'indice().\\

\textcolor{red}{Completar.}\\
\bigskip

{\large e)} \underline{Rutina de atenci\'on a las excepciones del procesador.}\\
%Modificar las rutinas de excepciones del procesador para que desalojen a la tarea que
%estaba corriendo y corran la pr\'oxima.\\


\textcolor{red}{Completar.}\\
\bigskip

{\large f)} \underline{Mecanismo de Debugging.}\\
%Implementar el mecanismo de debugging explicado en la secci\'on 3.4 que indicar\'a en pantalla
%la raz\'on del desalojo de una tarea.


\textcolor{red}{Completar.}\\
\end{document}


