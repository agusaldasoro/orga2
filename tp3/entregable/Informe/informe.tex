\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
%\usepackage{makeidx}
\usepackage{paralist} %itemize inline

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}


\input{codesnippet}
\input{page.layout}
% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}


% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %



\begin{document}


\thispagestyle{empty}
\materia{Organización del Computador II}
\submateria{Segundo Cuatrimestre de 2014}
\titulo{Trabajo Práctico III}
\subtitulo{System Programming - Zombi defense}
\integrante{Aldasoro Agustina}{86/13}{agusaldasoro@gmail.com}
\integrante{Rey Maximiliano}{37/13}{rey.maximiliano@gmail.com}
\integrante{Tirabasso Ignacio}{718/12}{ignacio.tirabasso@gmail.com}

 


\maketitle
\newpage

%\thispagestyle{empty}
%\vfill
%\begin{abstract}
%En el presente trabajo se describe la problemática de ...
%\end{abstract}

%\thispagestyle{empty}
%\vspace{3cm}
%\tableofcontents
\newpage


%\normalsize
\newpage
\section{Ejercicio 1}
{\large a)} \underline{Tabla de descriptores de la GDT.} \\

Al momento de armar la GDT, acorde a lo dispuesto en el enunciado, dejamos las primeras siete entradas de la tabla de descriptores libres. Luego, a partir de la posici\'on 8 dejamos los descriptores de segmento pedidos: c\'odigo y datos nivel 0 y c\'odigo y datos nivel 3.

Armamos los cuatro segmentos de la GDT, llam\'andolos: 
\begin{codesnippet}
\begin{verbatim}
    [GDT_IDX_DATA_0] = (gdt_entry) ;  
    [GDT_IDX_DATA_3] = (gdt_entry) ; 
    [GDT_IDX_CODE_0] = (gdt_entry) ; 
    [GDT_IDX_CODE_3] = (gdt_entry) ; 
\end{verbatim}
\end{codesnippet}

A los cuatro les seteamos el mismo \emph{l\'imite}: \textbf{0x26EFF} y la misma \emph{base} en \textbf{0}, de este modo los cuatro descriptores de segmento direccionan a los primeros \emph{623MB} de memoria. El \emph{segment type} var\'ia depende el segmento: CODE_0: \textbf{0x0A} (code execute/read), CODE_3: \textbf{0x0F} (code execute/read, conforming, accesed), DATA_0 y DATA_3: \textbf{0x02} (data read/write). El \emph{Descriptor type} va en todos para system, por lo tanto es \textbf{0}. El \emph{Descriptor privilege level} coincide con el nombre del descriptor (\textbf{0} para CODE_0 y DATA_0; \textbf{3} para CODE_3 y DATA_3). El bit de \emph{Present} va para todos en \textbf{1} y los bit de \emph{Available for use by system software} y \emph{l} van para todos en \textbf{0}. El bit de \emph{Default operation size} va para todos en \textbf{1} porque es un c\'odigo de 32bits. El bit de \emph{Granularity} va para todos en \textbf{1}.\\
    


{\large b)} \underline{Pasaje a modo protegido y seteo de la pila del kernel.}\\

Para pasar a modo protegido los pasos que debemos llevar a cabo son:


\begin{itemize}
\item[$\triangleright$] Completar la GDT (resuelto en el inciso A).
\item[$\triangleright$] Deshabilitar interrupciones (para ello se ejecuta la instrucci\'on \emph{cli}).
\item[$\triangleright$] Habilitar A20 (en nuestro caso se resuelve haciendo \emph{call habilitar_A20}).
\item[$\triangleright$] Cargar el registro GDTR con la direcci\'on base de la GDT (lo hacemos con la instrucci\'on  \\ \emph{lgdt} \emph{ [GDT_DESC]} la etiqueta GDT_DESC apunta al descriptor de la GDT en el c\'odigo).
\item[$\triangleright$] Una vez hecho esto, estamos en condiciones de setear el bit PE del registro CR0 (debemos hacer: \emph{mov eax,cr0 ; or eax,1 ; mov cr0,eax}).
\item[$\triangleright$] Lo siguiente a realizar es el \emph{jump far} a la siguiente instrucci\'on (utilizamos el selector de segmento \emph{0x50} y de offset la etiqueta \emph{modo_protegido} \textcolor{red}{por que el selector es 0x50??}).
\item[$\triangleright$] Una vez ya en modo protegido, nos encontramos trabajando en 32 bits y ahora es cuando cargamos los registros de segmento (a los registros  \emph{es, ds, ss y gs} les asignamos el valor de \emph{0x40} y al registro \emph{fs} le asignamos el valor \emph{0x60} \textcolor{red}{aca habr\'ia que poner el porque de estos valores??}).
\end{itemize}
 \bigskip	
Para setear la pila del kernel en la direcci\'on 0x27000 debemos llevar a cabo la siguiente instrucci\'on: 
\begin{codesnippet}
\begin{verbatim}
    mov ebp, 0x27000
\end{verbatim}
\end{codesnippet}

{\large c)} \underline{Segmento adicional que describe el \'area de la pantalla en memoria que puede ser utilizado} \\ \underline{s\'olo por el kernel.}
\\
\textcolor{red}{HELP! aca no se que ponerrrrrrrr}

\begin{codesnippet}
\begin{verbatim}
    ; Cambiar modo de video a 80 X 50
    mov ax, 0003h
    int 10h ; set mode 03h
    xor bx, bx
    mov ax, 1112h
    int 10h ; load 8x8 font
\end{verbatim}
\end{codesnippet}


{\large d)} \underline{Rutina que se encarga de limpiar la pantalla y pintar el \'area del mapa}
\\

En este punto debemos establecer un fondo de color verde, junto con las dos barras laterales para cada uno de los jugadores (una roja y otra azul). Para esto, debemos contar con una funci\'on que limpie la pantalla en un primer momento: \emph{clear_screen}.\\

La funci\'on \textbf{\textit{clear_screen}}, implementada en lenguaje C, se va a encargar de: 

\begin{itemize}
\item[$\triangleright$] Guardar en una variable local: \emph{size} el tama\~no de la pantalla (VIDEO_COLS * VIDEO_FILS).
\item[$\triangleright$] Luego va a hacer un while desde \emph{0} hasta \emph{size} que, empezando por la direcci\'on donde est\'a almacenada la memoria de video, vaya guardando el caracter que es todo negro.
\end{itemize}

De este  modo, logramos hacer que toda el \'area de la pantalla quede ``pintada'' de negro. \\

\bigskip

En segunda instancia, armamos la funci\'on \emph{print_map}. La funci\'on \textbf{\textit{print_map}}, tambi\'en implementada en lenguaje C, con el fin de pintar el \'area del mapa con los colores deseados, posee el siguiente comportamiento:

\begin{itemize}
\item[$\triangleright$] En un primer momento, llama a la funci\'on \emph{clear_screen}.
\item[$\triangleright$] Se arman cuatro variables locales: blue, red, green y black. Cada una de ellas es un caracter completamente de su color.
\item[$\triangleright$] Mediante dos \textit{fors} anidados recorremos toda el \'area del mapa, y dependiendo de la posici\'on en la que se encuentre es el color que le va a ser asignado (rojo a las primeras dos columnas de la izquierda, azul a las \'ultimas dos, negro a las \'ultimas cinco filas y el resto en verde).
\end{itemize}

Luego este c\'odigo fue complejizado para que pueda imprimir los puntos de los jugadores y sus respectivos puntajes por zombie tal cual debe ser cuando comienza el juego.
\newpage
\section{Ejercicio 2}
%{\large a)} 
\textcolor{red}{ESTO HAY QUE HACERLO!!!!!!!!} \\
%Inicializamos las entradas 0-19 en la IDT.




%{\large b)} \textcolor{red}{Para probar lo programado anteriormente hicimos:}

%\begin{codesnippet}
%\begin{verbatim}
%    ; Inicializar la IDT
 %   call idt_inicializar
 %   ; Cargar IDT
  %  lidt [IDT_DESC]
%
 %   ; test para que salte la divide by 0 exception (0)
  %  mov edx,0
   % mov ecx,0
   % mov eax,3
    %div ecx
%\end{verbatim}
%\end{codesnippet}

\newpage
\section{Ejercicio 3}
\textcolor{red}{Limpiar el buffer de video es hacer clear_screen???... Asumo que s\'i.}\\


{\large a)} \underline{Implementaci\'on completa de print_map.} \\

En el ejercicio 1 ya hab\'iamos logrado armar \textbf{clear_screen} y \textbf{print_map}, esta \'ultima contaba con una funcionalidad acotada. S\'olo armaba cuatro bloques de colores. Ahora lo que vamos a hacer es extender la funci\'on \textbf{print_map} para que escriba los puntos de los jugadores y marque el estado de los zombies, tal como aparece en la \textit{figura 9} del enunciado.\\


La funci\'on print_map la vamos a extender sum\'andole las siguientes instrucciones:

\begin{itemize}
\item[$\triangleright$] Debemos armar los \emph{cuadrados de puntaje} para el jugador rojo y para el jugador azul. Nos movemos entre las \'ultimas cinco filas, desde la columna 35 hasta la 39 se pintan con el caracter completamente rojo y desde la columna 40 hasta la 44 se pintan con el caracter completamente azul.
\item[$\triangleright$] Escribimos en el centro de cada cuadrado el puntaje inicial: 0. Para ello creamos dos caracteres que sean 0 y cada uno con los atributos necesarios para que sean: fondo rojo, letra blanca y fondo azul, letra blanca.
\item[$\triangleright$] Luego escribimos la cantidad de zombies restantes, para lo cual se utilizan dos caracteres id\'enticos a los mencionados arriba. Estos puntajes se ubican cada uno a un costado de su cuadrado respectivo.
\item[$\triangleright$] Por \'ultimo, resta escribir el estado de los zombies. Generamos un char* que sean todos los n\'umeros de zombies y d\'andole formato de fondo negro, caracter blanco los copiamos dos veces: uno para el jugador azul y otro para el jugador rojo. Como todos los zombies se encuentran disponibles, generamos otro char* que sean diez `x' y ubicamos en su posici\'on correspondiente uno que posea los atributos de fondo negro, caracter azul y otro de fondo negro, caracter rojo.
\end{itemize}

Con el objetivo de hacer que lo descripto anteriormente sea una tarea m\'as simple contamos con las funciones: \emph{print_string} y \emph{get_format}.\\

La funci\'on \textbf{print_string} recibe una posici\'on en el mapa (x,y), un char* con el texto que queremos imprimir en pantalla y un short con los atributos deseados. \textcolor{red}{PONER ALGO DE AVOID PRINT BUG}. Dentro de un \textit{for} que recorre horizontalmente la posici\'on en memoria a partir de la posici\'on (x,y), se va avanzando el char* y en cada iteraci\'on se le asigna a esa posici\'on de memoria el char actual con los atributos pasados por par\'ametro.\\
%    // avoid black print bug
%    unsigned char a = (unsigned char) attr;
%    if (a == 0) {
%        a = getFormat(C_FG_WHITE, 0, C_BG_BLACK, 0);
%    }

La funci\'on \textbf{get_format} es una funci\'on simple la cual recibe como par\'ametro los atributos deseados y los devuelve con el formato de un s\'olo char, que es el que debemos utilizar.
\begin{codesnippet}
\begin{verbatim}
unsigned char getFormat(unsigned char fore_color, char fore_bright, unsigned char back_color, 
                        char blink) {
    return fore_color | fore_bright | back_color | blink; 
}
\end{verbatim}
\end{codesnippet}


{\large b)} \underline{Rutinas encargadas de inicializar el directorio y tablas de p\'aginas para el kernel.}\\

Para poder mapear las direcciones 0x00000000 a 0x003FFFFF es necesaria una sola entrada en el Page Directory. En un primer momento, se crea un puntero a Page Directory en la direcci\'on 0x27000. Se limpian las 1024 entradas del Page Directory poniendo todos sus bits en 0.\\

Luego, a la primera entrada del Page Directory (\'indice: 0) se le asigna como base 0x28. Se le asigna permiso de escritura y lectura con su bit de presente seteado, como es de Kernel es de nivel 0.\\

Para que todo esto funcione y el primer \'indice del Page Directory apunte a un Page Table v\'alido, se debe crear un Page Table en la posici\'on 0x28000 en memoria. En esta misma se completan todos los \'indices (ya que es lo que ocupa el rango pedido para el Kernel) direccion\'andolos desde la posici\'on 0x0 en memoria, aumentando en uno acorde aumenta el \'indice. Todos tienen permiso de escritura con el bit de presente seteado, como es de Kernel es de nivel 0.\\



{\large c)} \underline{C\'odigo necesario para activar paginaci\'on.}\\

Como ya contamos con un directorio de p\'aginas y una tabla de p\'aginas estamos en condiciones de activar paginaci\'on.\\


Como para esto debemos poner en cr3 la base del directorio de p\'aginas y limpiar los bits PCD y PWT del mismo, basta con asignarle a cr3 el valor de 0x27000. De este modo la base queda en 0x27 y los bits limpios. \textcolor{red}{Es correcto esto?}\\

Por \'ultimo resta setear el bit PG del cr0, lo hacemos mediante un or.

\newpage
\section{Ejercicio 4}
{\large a)} \underline{inicializar_mmu.}\\


Para administrar la memoria en el área libre, tenemos un contador de páginas utilizadas denoninándolo \textit{páginas}. Luego contamos con las funciones \textit{get_page_directory} y \textit{get_page_table} las cuales nos brindan un nuevo page directory o una nueva page table correspondientemente.

\textcolor{red}{Todo esto aca del punto A esta re turbio...mirar que onda... ACA HAY QUE PONER GET_PAGE_TABLE Y GET_PAGE_DIRECTORY???}\\



% \begin{codesnippet}
% \begin{verbatim}
% page_directory* get_page_directory() {
%     page_directory* pd = (page_directory*) PAGES;
%     pd += paginas * 4096;
%     int i;
%     for (i = 0; i < 1024; i++) {
%         pd[i] = (page_directory) {};
%     }

%     pd[0] = (page_directory) {
%         .base = 0x28,
%         .rw = 0x1,
%         .p = 1
%     };

%     paginas++;

%     return pd;
% }
% \end{verbatim}
% \end{codesnippet}


% \begin{codesnippet}
% \begin{verbatim}
% page_table* get_page_table() {
%     page_table* pgt = (page_table*) PAGES;
%     pgt += paginas * 0x1000;
%     int i;
%     for (i = 0; i < 1024; i++) {
%         pgt[i] = (page_table) {};
%     }

%     paginas++;

%     return pgt
%     };
% }
% \end{verbatim}
% \end{codesnippet}

{\large b)} \underline{mmu_inicializar_dir_zombi}\\

La rutina \textit{mmu_inicializar_dir_zombi} se encarga de inicializar un directorio
de p\'aginas y tablas de p\'aginas para una tarea, respetando la figura 6. Copia
el c\'odigo de la tarea a su \'area asignada, es decir la posici\'on indicada por el jugador dentro
del mapa y mapea dichas p\'aginas a partir de la direcci\'on virtual 0x08000000(128MB).\\

\textcolor{red}{Este punto B tambien esta re turbio...}\\


{\large c)} \underline{Mapear y Des-Mapear p\'agina.}\\

 La rutina \textit{mmu_mapear_p\'agina} permite armar toda la estructura necesaria para que, dada una direcci\'on virtual, un puntero a Page Directory, una direcci\'on f\'isica y los atributos deseados (lectura/escritura y nivel); se mapee la direcci\'on virtual a la f\'isica.\\
 
El comportamiento de la funci\'on \textbf{mmu_mapear_p\'agina} consiste en :

\begin{itemize}
\item[$\triangleright$] Obtener el offset del Page_directory (\textit{directory}) shifteando a la derecha 22 bits la direcci\'on virtual pasada por par\'ametro.
\item[$\triangleright$] Obtener el offset del Page_table (\textit{table}) shifteando a la derecha 12 bits la direcci\'on virtual pasada por par\'ametro luego de haberle hecho un \emph{and} con 0x003FF000 as\'i obtengo s\'olo los bits de inter\'es.
\item[$\triangleright$] Si el \'indice \textit{directory} del Page Directory tiene el bit presente = 0, entonces debemos setear la base obteniendo una nueva Page Table (con la funci\'on get_page_table), d\'andole permismos de escritura y nivel acorde a lo pasado por par\'ametro y seteando el bit de presente.
\item[$\triangleright$] Obtener el puntero a la Page Table (\textit{pt}), accediendo al \'indice \textit{directory} del Page Directory pasado por par\'ametro, lo shifteamos a la izquierda 12 bits as\'i tenemos la direcci\'on de la p\'agina donde se encuentra la Page Table.
\item[$\triangleright$] En el \'indice \textit{table} de la Page Table apuntada por \textit{pt} le asignamos la direcci\'on f\'isica pasada por par\'ametro shifteada a la derecha 12 bits, asign\'andole permisos de lectura/escritura acorde y nivel a lo pasado por par\'ametro y seteando el bit de presente.
\item[$\triangleright$] Por \'ultimo, ejecutamos \emph{tlbflush} para que se invalide la cache de traducci\'on de direcciones.
\end{itemize}

\bigskip

A veces, vamos a necesitar des-mapear una p\'agina para que, bajo el cr3 actual, no se tenga m\'as permiso de acceso a la misma. Por este motivo, contamos con la funci\'on \textit{mmu_unmapear_pagina}.\\


La funci\'on \textbf{mmu_unmapear_pagina} va a recibir como par\'ametro una direcci\'on virtual y el cr3 actual. El comportamiento de esta funci\'on, si el bit de presente del Page Directory al que apunta al cr3 est\'a seteado, va a consistir en el simple acceso al Page Directory apuntado por el cr3, accediendo al \'indice descripto en la direcci\'on virtual pasada por par\'ametro. Luego dirigirse al Page Table apuntado por este, accediendo al \'indice que se encuentra en la direcci\'on virtual y una vez ah\'i limpiar el bit de presente. En otro caso, no es necesario tomar ninguna acci\'on.

\newpage
\section{Ejercicio 5}

{\large a)} \underline{Entradas necesarias en la IDT.}\\

Completamos las entradas necesarias en la IDT para asociar una rutina a la interrupci\'on del
reloj, otra a la interrupci\'on de teclado y por \'ultimo una a la interrupci\'on de software 0x66. Es decir las posiciones 32, 33 y 102.

Las primeras dos van a ser de privilegio 0 y la \'ultima de privilegio 3, asign\'andoselo mediante sus atributos.\\

\textcolor{red}{HASTA ACA LLEGUE, NO DOY FE DE LO DE ABAJO. IGUAL ARRIBA TAMBIEN HAY ANOTACIONES EN ROJO!}\\

{\large b)} A continuación, la rutina asociada a la interrupci\'on del reloj, para que por cada tick llame a la
funci\'on screen pr\'oximo reloj. La misma se encarga de mostrar cada vez que se llame, la
animaci\'on de un cursor rotando en la esquina inferior derecha de la pantalla. 

\begin{codesnippet}
\begin{verbatim}
;; Rutina de atención del RELOJ

global _isr32
_isr32:
    pushad
    call proximo_reloj 	 ; Ya definida en isr.asm
    call proximo_indice  ;Devuelve el próximo índice en la GDT a ejecutar

    cmp ax,0
    je .nojump

    mov [sched_tarea_selector], ax
    call fin_intr_pic1
    jmp far [sched_tarea_offset]
    jmp .end

.nojump:
    call fin_intr_pic1

.end:
    ; switchear tareas.
    popad
    iret
\end{verbatim}
\end{codesnippet}


{\large c)} Ahora, la rutina asociada a la interrupci\'on de teclado de forma que si se presiona cualquiera
de las teclas a utilizar en el juego, se presenta la misma en la esquina superior derecha de la pantalla. \\

\begin{codesnippet}
\begin{verbatim}
;; Rutina de atención del TECLADO

global _isr33
extern printf
extern print_int
extern handle_keyboard_interrumption
_isr33:
    pushad
    xor eax,eax
    in al, 0x60

    mov dword [esp], eax
    call handle_keyboard_interrumption
    
    mov dword  [esp + 0x], 0
    mov dword [esp + 0xc], 67
    mov dword [esp + 0x8], keyboard_str
    mov dword [esp + 0x4], eax
    call printf    ;función implementada por nosotros

    call fin_intr_pic1
    popad
    iret
\end{verbatim}
\end{codesnippet}


{\large d)} Escribimos la rutina asociada a la interrupci\'on 0x66 para que modifique el valor de eax por
0x42. 
\begin{codesnippet}
\begin{verbatim}
;; Rutina de atención 0x66

global _isr66
_isr33:

    mov eax,0x42
  
    iret
\end{verbatim}
\end{codesnippet}

\newpage
\section{Ejercicio 6}
{\large a)} Definimos tres entradas en la GDT que consideramos necesarias para ser usadas como descriptores
de TSS: una para ser utilizada por la tarea inicial, otra para la tarea actual y una \'ultima para la tarea siguiente.\\

{\large b)} Completamos la entrada de la TSS de la tarea Idle con la informaci\'on de la tarea Idle. La tarea Idle se encuentra en la direcci\'on 0x00016000. La pila se alojar\'a en la misma direcci\'on que la pila del kernel y ser\'a mapeada
con identity mapping. Esta tarea ocupa 1 pagina de 4KB y debe ser mapeada con identity mapping. Adem\'as la misma comparte el mismo CR3 que el kernel. \\

\begin{codesnippet}
\begin{verbatim}
void tss_inicializar() {
    int i = 0;
    while(i < CANT_ZOMBIS) {
        inUseA[i] = 0;
        inUseB[i] = 0;
        i++;
    }
    currentZombieA = 0;
    currentZombieB = 0;

    // inicializar tss_idle
    tss_inicializar_tarea_idle();

    memcpy(&tss_idle, &tss_inicial, sizeof(tss));
    memcpy(&tss_idle, &current_task, sizeof(tss));
    memcpy(&tss_idle, &next_task, sizeof(tss));

    gdt[GDT_INITIAL_TSS].base_31_24 = ((u32) (&tss_inicial) & 0xFF000000) >> 24;
    gdt[GDT_INITIAL_TSS].base_23_16 = ((u32) (&tss_inicial) & 0x00FF0000) >> 16;
    gdt[GDT_INITIAL_TSS].base_0_15  = (u32) (&tss_inicial) & 0x0000FFFF;

    gdt[GDT_CURRENT_TSS].base_31_24 = ((u32) (&current_task) & 0xFF000000) >> 24;
    gdt[GDT_CURRENT_TSS].base_23_16 = ((u32) (&current_task) & 0x00FF0000) >> 16;
    gdt[GDT_CURRENT_TSS].base_0_15  = (u32) (&current_task) & 0x0000FFFF;
}
\end{verbatim}
\end{codesnippet}


\begin{codesnippet}
\begin{verbatim}
void tss_inicializar_tarea_idle() {

    tss_idle = (tss) {};

    tss_idle.eip = 0x00016000;
    tss_idle.cr3 = 0x27000;
    
    tss_idle.ebp = 0x27000;
    tss_idle.esp = 0x27000;

    tss_idle.es = 0x40;
    tss_idle.ds = 0x40;
    tss_idle.ss = 0x40;
    tss_idle.gs = 0x40;
    tss_idle.cs = 0x50;

    tss_idle.eflags = 0x202;
    tss_idle.iomap = 0xffff;
}
\end{verbatim}
\end{codesnippet}

%{\large c)} Construir una funci\'on que complete una TSS libre con los datos correspondientes a una
%tarea (zombi). El c\'odigo de las tareas se encuentra a partir de la direcci\'on 0x00010000
%ocupando una pagina de 4kb cada una seg\'un indica la figura 1. Para la direcci\'on de la
%pila se debe utilizar el mismo espacio de la tarea, la misma crecer\'a desde la base de la tarea. 
%Para el mapa de memoria se debe construir uno nuevo utilizando la funci\'on mmu inicializar dir zombi. 
%Adem\'as, tener en cuenta que cada tarea utilizar\'a una pila distinta de nivel 0, para esto se debe pedir una nueva pagina libre a tal fin. \\

%\textcolor{red}{Y aca que onda?}\\

{\large d)} C\'odigo necesario para ejecutar la tarea Idle, es decir, saltar intercambiando las
TSS, entre la tarea inicial y la tarea Idle:

\begin{codesnippet}
\begin{verbatim}
idle:
    .loopear:
        inc dword [numero]
        cmp dword [numero], 0x4
        jb .imprimir

    .reset_contador:
        mov dword [numero], 0x0

    .imprimir:
        ; Imprimir 'reloj'
        mov ebx, dword [numero]
        add ebx, message1
        imprimir_texto_mp ebx, 1, 0x0f, 49, 76
        mov ebx, chirimbolo_open
        imprimir_texto_mp ebx, 1, 0x0f, 49, 76-1
        mov ebx, chirimbolo_close
        imprimir_texto_mp ebx, 1, 0x0f, 49, 76+1

    jmp .loopear
\end{verbatim}
\end{codesnippet}

\newpage
\section{Ejercicio 7}
%{\large a)} Construir una funci\'on para inicializar las estructuras de datos del scheduler.\\

%\textcolor{red}{COMPLETAR!}\\

%{\large b)} Crear la funci\'on sched pr\'oximo indice() que devuelve el \'indice en la GDT de la pr\'oxima
%tarea a ser ejecutada. Construir la rutina de forma devuelva una tarea de cada jugador
%por vez seg\'un se explica en la secci\'on 3.2\\


%\textcolor{red}{COMPLETAR!}\\

{\large c)} Se muestra la rutina de la interrupci\'on 0x66, para que implemente el servicio mover seg\'un
se indica en la secci\'on 3.1.1.\\

\begin{codesnippet}
\begin{verbatim}
global _isr66
extern movimiento
_isr66:
    pushad
    
    push dx
    push esi
    push edi
    push eax
    call movimiento

    popad
    iret
\end{verbatim}
\end{codesnippet}


%{\large d)} Modificar el c\'odigo necesario para que se realice el intercambio de tareas por cada ciclo de
%reloj. El intercambio se realizar\'a seg\'un indique la funci\'on sched proximo \'indice().\\


%\textcolor{red}{COMPLETAR!}\\


%{\large e)} Modificar las rutinas de excepciones del procesador para que desalojen a la tarea que
%estaba corriendo y corran la pr\'oxima.\\

%\textcolor{red}{COMPLETAR!}\\

%{\large f)} Implementar el mecanismo de debugging explicado en la secci\'on 3.4 que indicar\'a en pantalla
%la raz\'on del desalojo de una tarea.


%\textcolor{red}{COMPLETAR!}\\

\end{document}


