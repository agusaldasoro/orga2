\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
%\usepackage{makeidx}
\usepackage{paralist} %itemize inline

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}


\input{codesnippet}
\input{page.layout}
% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}


% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %



\begin{document}


\thispagestyle{empty}
\materia{Organización del Computador II}
\submateria{Segundo Cuatrimestre de 2014}
\titulo{Trabajo Práctico III}
\subtitulo{System Programming - Zombi defense}
\integrante{Aldasoro Agustina}{86/13}{agusaldasoro@gmail.com}
\integrante{Rey Maximiliano}{37/13}{rey.maximiliano@gmail.com}
\integrante{Tirabasso Ignacio}{718/12}{ignacio.tirabasso@gmail.com}

 


\maketitle
\newpage

%\thispagestyle{empty}
%\vfill
%\begin{abstract}
%En el presente trabajo se describe la problemática de ...
%\end{abstract}

%\thispagestyle{empty}
%\vspace{3cm}
%\tableofcontents
\newpage


%\normalsize
\newpage
\section{Ejercio 1}
{\large a)} Armamos los cuatro segmentos de la GDT, llam\'andolos: 
\begin{codesnippet}
\begin{verbatim}
    [GDT_IDX_CODE_0] = (gdt_entry) ; 
    [GDT_IDX_CODE_3] = (gdt_entry) ; 
    [GDT_IDX_DATA_0] = (gdt_entry) ;  
    [GDT_IDX_DATA_3] = (gdt_entry) ; 
\end{verbatim}
\end{codesnippet}
    
A los cuatro les seteamos el mismo \emph{l\'imite}: 0x26EFF = ... , y la misma \emph{base} en 0. El \emph{segment type} var\'ia depende el segmento: CODE_0: 0x0A= ... , CODE_3: 0x0F= ... , DATA_0 y DATA_3: 0x02= ... . El \emph{Descriptor type} va en todos para system, por lo tanto es 0. El \emph{Descriptor privilege level} coincide con el nombre del descriptor (0 para CODE_0 y DATA_0; 3 para CODE_3 y DATA_3). El bit de \emph{Present} va para todos en 1 y los bit de \emph{Available for use by system software} y \emph{l} van para todos en 0. El bit de \emph{Default operation size} va para todos en 1 porque es un c\'odigo de 32bits. El bit de \emph{Granularity} va para todos en 1.\\
    


{\large b)} Se adjunta el c\'odigo necesario para pasar a modo protegido y setear la pila del kernel en
la direcci\'on 0x27000.


\begin{codesnippet}
\begin{verbatim}
    ; Deshabilitar interrupciones
    cli
  
    ; Habilitar A20
    call habilitar_A20
	
    ; Cargar la GDT
    lgdt [GDT_DESC]

    ; Setear el bit PE del registro CR0
    mov eax,cr0
    or eax,1
    mov cr0,eax

    jmp 0x50:modo_protegido
\end{verbatim}
\end{codesnippet}
\begin{codesnippet}
\begin{verbatim}
BITS 32
modo_protegido:

    ; Establecer selectores de segmentos
    xor eax, eax
    mov ax, 0x40
     
    mov es, ax
    mov ds, ax
    mov ss, ax    
    mov gs, ax

    mov ax, 0x60 
    mov fs, ax
    
    ; Establecer la base de la pila
    mov ebp, 0x27000
\end{verbatim}
\end{codesnippet}

{\large c)} Segmento adicional que describe el \'area de la pantalla en memoria que puede
ser utilizado solo por el kernel:
\begin{codesnippet}
\begin{verbatim}
    ; Cambiar modo de video a 80 X 50
    mov ax, 0003h
    int 10h ; set mode 03h
    xor bx, bx
    mov ax, 1112h
    int 10h ; load 8x8 font
\end{verbatim}
\end{codesnippet}


{\large d)} La siguiente es la rutina que se encarga de limpiar la pantalla y pintar el \'area del mapa
un fondo de color verde, junto con las dos barras laterales para cada uno de
los jugadores (rojo y azul).
\begin{codesnippet}
\begin{verbatim}
    ; Inicializar pantalla
    call clear_screen
    call print_map ;código que va a pintar el mapa de los colores deseados
\end{verbatim}
\end{codesnippet}
\begin{codesnippet}
\begin{verbatim}
void clear_screen() {
    int size = VIDEO_COLS * VIDEO_FILS;    
    ca (*p) = (ca (*)) VIDEO; 
    int i = 0;
    ca empty;
    empty.c = 0;
    empty.a = getFormat(C_FG_BLACK, 0, C_BG_BLACK, 0);
    while(i < size) {
        p[i] = empty;
        i++;
    }
}
\end{verbatim}
\end{codesnippet}

\newpage
\section{Ejercio 2}
{\large a)} Inicializamos las entradas 0-19 en la IDT.





{\large b)} Para probar lo programado anteriormente hicimos:

\begin{codesnippet}
\begin{verbatim}
    ; Inicializar la IDT
    call idt_inicializar
    ; Cargar IDT
    lidt [IDT_DESC]

    ; test para que salte la divide by 0 exception (0)
    mov edx,0
    mov ecx,0
    mov eax,3
    div ecx
\end{verbatim}
\end{codesnippet}

\newpage
\section{Ejercio 3}
{\large a)} La siguiente es la rutina que se encarga de limpiar el buffer de video y pintarlo como indica
la figura 9. 

\begin{codesnippet}
\begin{verbatim}
void print_map() {
    int cols = VIDEO_COLS;
    int rows = VIDEO_FILS;

    ca (*screen)[VIDEO_COLS] = (ca (*)[VIDEO_COLS]) VIDEO;

	/* Defino los colores que voy a usar */
    ca red;
    red.c = 0;
    red.a = getFormat(C_FG_RED, 0, C_BG_RED, 0);
    ca blue;
    blue.c = 0;
    blue.a = getFormat(C_FG_BLUE, 0, C_BG_BLUE, 0);
    ca green;
    green.c = 0;
    green.a = getFormat(C_FG_GREEN, 0, C_BG_GREEN, 0);
    ca black;
    black.c = 0;
    black.a = getFormat(C_FG_BLACK, 0, C_BG_BLACK, 0);

    int y,x;

    clear_screen();
    
    for(y = 0; y < rows; y++) {
        for(x = 0; x < cols; x++) {
            if (y >= rows-5) {
                screen[y][x] = black;		//las últimas 5 filas van de negro
            } else if (x == cols-1) {
                screen[y][x] = blue;		//el jugador de la derecha es azul
            } else if (x == 0) {
                screen[y][x] = red;			//el jugador de la izquierda es rojo
            } else {
                screen[y][x] = green;		//el terreno de juego es verde
            }
        }
    }
    /*Armo el cuadrado para el puntaje rojo */
    for(y = rows-5; y < rows; y++) {
        for(x = 35; x < 40; x++) {
            screen[y][x] = red;
        }
    }
    /*Armo el cuadrado para el puntaje azul */
    for(y = rows-5; y < rows; y++) {
        for(x = 40; x < 45; x++) {
            screen[y][x] = blue;
        }
    }

\end{verbatim}
\end{codesnippet}

\begin{codesnippet}
\begin{verbatim}
    /** Escribe a los numeritos de los zombies de cada jugador con sus cruces*/
    char * text = "1 2 3 4 5 6 7 8 9 10", 0;
    print_string(text, 4, 46, getFormat(C_FG_WHITE, 0, C_BG_BLACK  , 0));
    print_string(text, 60, 46, getFormat(C_FG_WHITE, 0, C_BG_BLACK  , 0));

    text = "x x x x x x x x x x",0;
    print_string(text, 4, 48, getFormat(C_FG_RED, 0, C_BG_BLACK  , 0));
    print_string(text, 60, 48, getFormat(C_FG_RED, 0, C_BG_BLACK  , 0));

    /** Imprime puntajes */
    text = "00",0;
    print_string(text, 31, 47, getFormat(C_FG_WHITE, 0, C_BG_RED  , 0));
    print_string(text, 48, 47, getFormat(C_FG_WHITE, 0, C_BG_BLUE , 0));

    text = "0",0;
    print_string(text, 37, 47, getFormat(C_FG_WHITE, 0, C_BG_RED  , 0));
    print_string(text, 42, 47, getFormat(C_FG_WHITE, 0, C_BG_BLUE , 0));
}
\end{verbatim}
\end{codesnippet}

{\large b)} Se muestran las rutinas encargadas de inicializar el directorio y tablas de p\'aginas para el kernel
(mmu_inicializar_dir_kernel). 

\begin{codesnippet}
\begin{verbatim}
void mmu_inicializar_dir_kernel() {
    page_directory *pd = (page_directory *) 0x27000;
    int i;

    /* Creo 1024 entradas en page_directory con todo cero. */
    for (i = 0; i < 1024; i++) {
        pd[i] = (page_directory) {};
    }

    /* Mapeo las primeras 4 (0,1,2,3) entradas del page directory
    con la base y permisos correspondientes. */
    for(i = 0; i < 4; i++) {
        pd[i] = (page_directory) {
            .base = 0x28 + i,
            .rw = 0x1,
            .p = 1,
        };
    }

    page_table* pt = (page_table*) 0x28000;
    for(i = 0; i < 1024; i++) {
        pt[i] = (page_table) {
            .base = i,
            .rw = 0x1,
            .p = 1,
        };
    }
}
\end{verbatim}
\end{codesnippet}



{\large c)} Completamos el c\'odigo necesario para activar paginaci\'on.\\

\begin{codesnippet}
\begin{verbatim}
    ; Habilitar paginacion

    mov eax,0x27000
    mov cr3,eax

    mov eax,cr0
    or eax,0x80000000
    mov cr0,eax


    mov eax,0x100000
    mov cr3,eax
\end{verbatim}
\end{codesnippet}

\newpage
\section{Ejercio 4}
{\large a)} Para administrar la memoria en el área libre, tenemos un contador de páginas utilizadas denoninándolo \textit{páginas}. Luego contamos con las funciones \textit{get_page_directory} y \textit{get_page_table} las cuales nos brindan un nuevo page directory o una nueva page table correspondientemente.


\begin{codesnippet}
\begin{verbatim}
page_directory* get_page_directory() {
    page_directory* pd = (page_directory*) PAGES;
    pd += paginas * 4096;
    int i;
    for (i = 0; i < 1024; i++) {
        pd[i] = (page_directory) {};
    }

    pd[0] = (page_directory) {
        .base = 0x28,
        .rw = 0x1,
        .p = 1
    };

    paginas++;

    return pd;
}
\end{verbatim}
\end{codesnippet}


\begin{codesnippet}
\begin{verbatim}
page_table* get_page_table() {
    page_table* pgt = (page_table*) PAGES;
    pgt += paginas * 0x1000;
    int i;
    for (i = 0; i < 1024; i++) {
        pgt[i] = (page_table) {};
    }

    paginas++;

    return pgt
    };
}
\end{verbatim}
\end{codesnippet}
{\large b)} La rutina \textit{mmu_inicializar_dir_zombi} se encarga de inicializar un directorio
de p\'aginas y tablas de p\'aginas para una tarea, respetando la figura 6. Copia
el c\'odigo de la tarea a su \'area asignada, es decir la posici\'on indicada por el jugador dentro
del mapa y mapea dichas p\'aginas a partir de la direcci\'on virtual 0x08000000(128MB).


\begin{codesnippet}
\begin{verbatim}
/* Guerrero = 0, Mago = 1, Clerigo = 2
   player = 0 es A
   player = 1 es B
*/
  page_directory* mmu_inicializar_dir_zombie(unsigned int player, unsigned char class, 
  unsigned int y) {

    page_directory* pd = get_page_directory();
    unsigned int x = (player ? 79 : 2);

    unsigned int offset_x[9] = {0, -1, -1, -1, 0, 0, 1, 1, 1};
    unsigned int offset_y[9] = {0, 0, -1, 1, -1, 1, 0, 1, -1};

    /* En este for se mapean las nueve páginas correspondientes a un jugador */
    int i, _x, _y;
    for(i = 0; i < 9; i++) {
        _x = y + offset_x[i] * (player ? 1 : -1);  \\ x es la posición x dentro del mapa
        _y = x + offset_y[i] * (player ? 1 : -1);  \\ y es la posición y dentro del mapa

        /* La función get_physical_address devuelve la dirección física en memoria
        a la cual le corresponde el par (x, y) pasado por parámetro */      
        mmu_mapear_pagina(0x8000000 + (i*0x1000), pd, get_physical_address(_x, _y), 1, 0);      
    }

    /* Código para copiar la tarea del Zombie */
    int address = address = 0x10000 + (player ? 0 : 1)  * 0x3000 + class * 0x1000;
    i = 0;
    unsigned char *code = (unsigned char *) 0x8000000;
    unsigned char * paddress = (unsigned char*) address;
    while (i++ < 0x1000) {
        code[i] = paddress[i];
    }
    
    return pd;
}
\end{verbatim}
\end{codesnippet}



{\large c)} La rutina \textit{mmu_mapear_p\'agina} permite mapear la p\'agina f\'isica correspondiente a su f\'isica en la direcci\'on virtual utilizando cr3.

\begin{codesnippet}
\begin{verbatim}
void mmu_mapear_pagina(unsigned int virtual, page_directory* pd, unsigned int fisica, 
   unsigned char rw, unsigned char us) {

    unsigned int directory = (virtual >> 22);
    unsigned int table     = (virtual & 0x003FF000) >> 12;

    page_table* pt = (page_table*) (pd[directory].base << 12);

    if (pd[directory].p == 0){
        pd[directory].base = ((unsigned int) get_page_table()) >> 12;
        pd[directory].rw = rw;
	    pd[directory].us = us;
        pd[directory].p = 1;
    }

    pt = (page_table*) (pd[directory].base << 12);
    pt[table].base = fisica >> 12;
    pt[table].rw = rw;
    pt[table].us = us;
    pt[table].p = 1;

    tlbflush();
}
\end{verbatim}
\end{codesnippet}


\textit{mmu_unmapear_pagina }  borra el mapeo creado en la direcci\'on virtual virtual utilizando cr3. \\


\begin{codesnippet}
\begin{verbatim}
 void mmu_unmapear_pagina(unsigned int virtual,page_directory* cr3){
 	unsigned int directory = (virtual >> 22);
    unsigned int table     = (virtual & 0x003FF000) >> 12;

    page_table* pt = (page_table*) (cr3[directory].base << 12);

    if (cr3[directory].p != 0){
        pt = (page_table*) (cr3[directory].base << 12);
        pt[table].p = 0;
    }

    tlbflush();
 }
\end{verbatim}
\end{codesnippet}

\newpage
\section{Ejercio 5}

{\large a)} Completamos las entradas necesarias en la IDT para asociar una rutina a la interrupci\'on del
reloj, otra a la interrupci\'on de teclado y por \'ultimo una a la interrupci\'on de software 0x66. Es decir las posiciones 32,33 y 66.


{\large b)} A continuación, la rutina asociada a la interrupci\'on del reloj, para que por cada tick llame a la
funci\'on screen pr\'oximo reloj. La misma se encarga de mostrar cada vez que se llame, la
animaci\'on de un cursor rotando en la esquina inferior derecha de la pantalla. 

\begin{codesnippet}
\begin{verbatim}
;; Rutina de atención del RELOJ

global _isr32
_isr32:
    pushad
    call proximo_reloj 	 ; Ya definida en isr.asm
    call proximo_indice  ;Devuelve el próximo índice en la GDT a ejecutar

    cmp ax,0
    je .nojump

    mov [sched_tarea_selector], ax
    call fin_intr_pic1
    jmp far [sched_tarea_offset]
    jmp .end

.nojump:
    call fin_intr_pic1

.end:
    ; switchear tareas.
    popad
    iret
\end{verbatim}
\end{codesnippet}


{\large c)} Ahora, la rutina asociada a la interrupci\'on de teclado de forma que si se presiona cualquiera
de las teclas a utilizar en el juego, se presenta la misma en la esquina superior derecha de la pantalla. \\

\begin{codesnippet}
\begin{verbatim}
;; Rutina de atención del TECLADO

global _isr33
extern printf
extern print_int
extern handle_keyboard_interrumption
_isr33:
    pushad
    xor eax,eax
    in al, 0x60

    mov dword [esp], eax
    call handle_keyboard_interrumption
    
    mov dword  [esp + 0x], 0
    mov dword [esp + 0xc], 67
    mov dword [esp + 0x8], keyboard_str
    mov dword [esp + 0x4], eax
    call printf    ;función implementada por nosotros

    call fin_intr_pic1
    popad
    iret
\end{verbatim}
\end{codesnippet}


{\large d)} Escribimos la rutina asociada a la interrupci\'on 0x66 para que modifique el valor de eax por
0x42. 
\begin{codesnippet}
\begin{verbatim}
;; Rutina de atención 0x66

global _isr66
_isr33:
    pushad
    mov eax,0x42
  
    iret
\end{verbatim}
\end{codesnippet}

\newpage
\section{Ejercio 6}
{\large a)} Definimos tres entradas en la GDT que consideramos necesarias para ser usadas como descriptores
de TSS: una para ser utilizada por la tarea inicial, otra para la tarea actual y una \'ultima para la tarea siguiente.\\

{\large b)} Completamos la entrada de la TSS de la tarea Idle con la informaci\'on de la tarea Idle. La tarea Idle se encuentra en la direcci\'on 0x00016000. La pila se alojar\'a en la misma direcci\'on que la pila del kernel y ser\'a mapeada
con identity mapping. Esta tarea ocupa 1 pagina de 4KB y debe ser mapeada con identity mapping. Adem\'as la misma comparte el mismo CR3 que el kernel. \\

\begin{codesnippet}
\begin{verbatim}
void tss_inicializar() {
    int i = 0;
    while(i < CANT_ZOMBIS) {
        inUseA[i] = 0;
        inUseB[i] = 0;
        i++;
    }
    currentZombieA = 0;
    currentZombieB = 0;

    // inicializar tss_idle
    tss_inicializar_tarea_idle();

    memcpy(&tss_idle, &tss_inicial, sizeof(tss));
    memcpy(&tss_idle, &current_task, sizeof(tss));
    memcpy(&tss_idle, &next_task, sizeof(tss));

    gdt[GDT_INITIAL_TSS].base_31_24 = ((u32) (&tss_inicial) & 0xFF000000) >> 24;
    gdt[GDT_INITIAL_TSS].base_23_16 = ((u32) (&tss_inicial) & 0x00FF0000) >> 16;
    gdt[GDT_INITIAL_TSS].base_0_15  = (u32) (&tss_inicial) & 0x0000FFFF;

    gdt[GDT_CURRENT_TSS].base_31_24 = ((u32) (&current_task) & 0xFF000000) >> 24;
    gdt[GDT_CURRENT_TSS].base_23_16 = ((u32) (&current_task) & 0x00FF0000) >> 16;
    gdt[GDT_CURRENT_TSS].base_0_15  = (u32) (&current_task) & 0x0000FFFF;
}
\end{verbatim}
\end{codesnippet}


\begin{codesnippet}
\begin{verbatim}
void tss_inicializar_tarea_idle() {

    tss_idle = (tss) {};

    tss_idle.eip = 0x00016000;
    tss_idle.cr3 = 0x27000;
    
    tss_idle.ebp = 0x27000;
    tss_idle.esp = 0x27000;

    tss_idle.es = 0x40;
    tss_idle.ds = 0x40;
    tss_idle.ss = 0x40;
    tss_idle.gs = 0x40;
    tss_idle.cs = 0x50;

    tss_idle.eflags = 0x202;
    tss_idle.iomap = 0xffff;
}
\end{verbatim}
\end{codesnippet}

{\large c)} Construir una funci\'on que complete una TSS libre con los datos correspondientes a una
tarea (zombi). El c\'odigo de las tareas se encuentra a partir de la direcci\'on 0x00010000
ocupando una pagina de 4kb cada una seg\'un indica la figura 1. Para la direcci\'on de la
pila se debe utilizar el mismo espacio de la tarea, la misma crecer\'a desde la base de la tarea. Para el mapa de memoria se debe construir uno nuevo utilizando la funci\'on mmu inicializar dir zombi. Adem\'as, tener en cuenta que cada tarea utilizar\'a una pila distinta de nivel 0, para esto se debe pedir una nueva pagina libre a tal fin. \\

\textcolor{red}{Y aca que onda?}\\

{\large d)} C\'odigo necesario para ejecutar la tarea Idle, es decir, saltar intercambiando las
TSS, entre la tarea inicial y la tarea Idle:

\begin{codesnippet}
\begin{verbatim}
idle:
    .loopear:
        inc dword [numero]
        cmp dword [numero], 0x4
        jb .imprimir

    .reset_contador:
        mov dword [numero], 0x0

    .imprimir:
        ; Imprimir 'reloj'
        mov ebx, dword [numero]
        add ebx, message1
        imprimir_texto_mp ebx, 1, 0x0f, 49, 76
        mov ebx, chirimbolo_open
        imprimir_texto_mp ebx, 1, 0x0f, 49, 76-1
        mov ebx, chirimbolo_close
        imprimir_texto_mp ebx, 1, 0x0f, 49, 76+1

    jmp .loopear
\end{verbatim}
\end{codesnippet}

\newpage
\section{Ejercio 7}
{\large a)} Construir una funci\'on para inicializar las estructuras de datos del scheduler.\\

\textcolor{red}{COMPLETAR!}\\

{\large b)} Crear la funci\'on sched pr\'oximo indice() que devuelve el \'indice en la GDT de la pr\'oxima
tarea a ser ejecutada. Construir la rutina de forma devuelva una tarea de cada jugador
por vez seg\'un se explica en la secci\'on 3.2\\


\textcolor{red}{COMPLETAR!}\\

{\large c)} Se muestra la rutina de la interrupci\'on 0x66, para que implemente el servicio mover seg\'un
se indica en la secci\'on 3.1.1.\\

\begin{codesnippet}
\begin{verbatim}
global _isr66
extern movimiento
_isr66:
    pushad
    
    push dx
    push esi
    push edi
    push eax
    call movimiento

    popad
    iret
\end{verbatim}
\end{codesnippet}


{\large d)} Modificar el c\'odigo necesario para que se realice el intercambio de tareas por cada ciclo de
reloj. El intercambio se realizar\'a seg\'un indique la funci\'on sched proximo \'indice().\\


\textcolor{red}{COMPLETAR!}\\


{\large e)} Modificar las rutinas de excepciones del procesador para que desalojen a la tarea que
estaba corriendo y corran la pr\'oxima.\\

\textcolor{red}{COMPLETAR!}\\

{\large f)} Implementar el mecanismo de debugging explicado en la secci\'on 3.4 que indicar\'a en pantalla
la raz\'on del desalojo de una tarea.


\textcolor{red}{COMPLETAR!}\\

\end{document}


