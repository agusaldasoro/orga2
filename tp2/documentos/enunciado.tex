\subsection{Mediciones}

Realizar una medición de performance \emph{rigurosa} es más difícil de lo 
que parece. 
En este experimento deberá realizar distintas mediciones de performance 
para verificar que sean buenas mediciones.

En un sistema ``ideal'' el proceso medido corre solo, sin ninguna 
interferencia de agentes externos. 
Sin embargo, una PC no es un sistema ideal. 
Nuestro proceso corre junto con decenas de otros, tanto de usuarios como 
del sistema operativo que compiten por el uso de la CPU. 
Esto implica que al realizar mediciones aparezcan ``ruidos'' o 
``interferencias'' que distorsionen los resultados.

El primer paso para tener una idea de si la medición es buena o no, 
es tomar varias muestras. 
Es decir, repetir la misma medición varias veces.
Luego de eso, es conveniente descartar los outliers
\footnote{en español, valor atípico: \url{http://es.wikipedia.org/wiki/Valor_atípico}}, 
que son los valores que más se alejan del promedio. 
Con los valores de las mediciones resultantes se puede calcular el promedio 
y también la varianza, que es algo similar el promedio de las distancias al 
promedio\footnote{en realidad, elevadas al cuadrado en vez de tomar el módulo}.

Las fórmulas para calcular el promedio $\mu$ y la varianza $\sigma^2$ son

$$
\mu = \frac{1}{n}\sum_{i=1}^{n} x_i \qquad \sigma^2 = \frac{\displaystyle\sum_{i=1}^{n}(x_i - \mu)^2} {n}
$$
%------------------------------------------

\subsection{Filtro \textit{cropflip}}

Programar el filtro \textit{cropflip} en lenguaje C y luego en ASM haciendo 
uso de las instrucciones vectoriales (\textbf{SSE}).

% ******************************************************************************
\vspace*{0.3cm} \noindent
\textbf{Experimento 1.1 - análisis el código generado}

En este experimento vamos a utilizar la herramienta \verb|objdump| para 
verificar como el compilador de C deja ensamblado el código C.

Ejecutar 
\begin{codesnippet}
\begin{verbatim}
objdump -Mintel -D cropflip_c.o
\end{verbatim}
\end{codesnippet}

¿Cómo es el código generado? 
Indicar\\
\begin{inparaenum}[\itshape a\upshape)]
    \item Por qué cree que hay otras funciones además de \verb|cropflip_c|
    \item Cómo se manipulan las variables locales
    \item Si le parece que ese código generado podría optimizarse
\end{inparaenum}\\
\\
\indent Muchas de las funciones generadas se agregan al compilar usando parámetros de debugging.\\ 
\indent El cambio que puede notarse a simple vista es que el tamaño del código generado con optimización es considerablemente menor al generado sin optimizaciones, un 34\% menor. Por otro lado, calcula una única vez la posición de la cual deberá leer el pixel a procesar, ya que es una operación que se realiza cuatro veces por cada lectura y escritura de un pixel. \\
\indent El c\'odigo optimizado también disminuye el uso del stack para variables locales y en su lugar utiliza registros, por esa razón necesita armar el stackframe y pushear los registros que la convención C pide preservar. Esto no se da en el c\'odigo sin optimizar, todas las variables locales se guardar en el stack, se asignan a algún registro libre al momento de usarla y luego vuelve a ser guardada en el stack. Si bien la cantidad de accesos a memoria es sustencialmente mayor en el c\'odigo sin optimizar por el hecho de que se accede constantemente a las variables locales alojadas en el stack, también hay que considerar que al haber tantos accesos al stack el hit-rate de la caché debería ser bastante alto, agilizando la lectura, no así la escritura. \\

% ******************************************************************************
%\newpage
\vspace*{0.3cm} \noindent
\textbf{Experimento 1.2 - optimizaciones del compilador}

Compile el código de C con flags de optimización. Por ejemplo, pasando el flag 
\verb|-O1|\footnote{agregando este flag a \texttt{CCFLAGS64} en el makefile}. 
Indicar\\
\begin{inparaenum}
    \item Qué optimizaciones observa que realizó el compilador\\
    \item Qué otros flags de optimización brinda el compilador\\
    \item Los nombres de tres optimizaciones que realizan los compiladores.\\
\end{inparaenum}\\
\\
\indent GCC provee un arsenal de optimizaciones disponibles para que podamos usar cuando lo creamos conveniente, asímismo provee unos flags para poder compilar el código con un conjunto de optimizaciones, estos son O1, O2, O3, Os, entre otros. O1, O2 y O3 son optimizaciones generales no agresivas, es decir, no deberían modificar el funcionamiento del programa. Otras optimizaciones podrían asumir que todas las operaciones aritméticas son sin signo o que están bien implementadas y no es necesario chequear la consistencia de los resultados (fno-math-errno). Estas optimizaciones tienen como objetivo mejorar la performance del programa, sin embargo Os tiene como objetivo reducir el tamaño del ejecutable, es decir, activa todas las optimizaciones que contribuyen a reducir la cantidad de instrucciones regardless del impacto que esto pueda tener en la performance del programa. \\
\indent Concretamente al activar las optimizaciones O3 en cropflip el cambio más notorio es que GCC utiliza instrucciones SSE para procesar 4 pixels por iteración, lo cual le brinda un boost de velocidad impresionante. Además de haberse reducido la cantidad de instrucciones. \\
\\
%----------------------------------------------
\vspace*{0.3cm} \noindent
\textbf{Experimento 1.3 - calidad de las mediciones}

\begin{enumerate}
    \item Medir el tiempo de ejecución de cropflip 10 veces. Calcular el promedio y la varianza. Consideraremos outliers a los 2 mayores tiempos de ejecución de la medicion y también a los 2 menores, por lo que los descartaremos. Recalcular el promedio y la varianza después de hacer este descarte. Realizar un gráfico que presente estos dos últimos items.\\
\\
Luego de ejecutar 10 veces el filtro Cropflip obtuvimos los siguientes resultados: \\
\\
    	\begin{tabular}[c]{|c|c|c|}
	\hline
		\textbf{ASM} & \textbf{C}\\
		\hline
70.925 &	1.152.187\\
		\hline
70.521 &	1.151.544\\
		\hline
32.859 &	761.937\\
		\hline
43.720 &	649.248\\
		\hline
64.236 &	1.152.847\\
		\hline
70.793 &	1.153.061\\
		\hline
71.271 &	1.152.765\\
		\hline
44.616 &	1.152.798\\
		\hline
56.124 &	725.420\\
		\hline
71.775 &	1.155.718\\
		\hline
	\textbf{Esperanza}	\\
		\hline
59.684 & 1.020.752,5 \\
		\hline
		\textbf{Desvío est\'andar}	\\
		\hline
13.720,5329 & 203.626,443 \\
		\hline
	\end{tabular}\\\\


	El cuadro denota la cantidad de ciclos de clock utilizada por cada ejecuci\'on del programa. \\
	\\
	Se puede apreciar que la esperanza (promedio de las mediciones) bajo Lenguaje C es notablemente mayor para las diez mediciones llevadas a cabo. Adem\'as poseen una desviaci\'on est\'andar tambi\'en mayor. La desviación estándar mide el grado de dispersión o variabilidad, por lo que demuestra menor estabilidad en las mediciones bajo Lenguaje C. Por lo tanto podemos afirmar que bajo el contexto de nuestras mediciones el tiempo de ejecuci\'on del mismo programa en lenguaje ASM posee un tiempo de c\'omputo menor. \\
\\	
	
	Luego de eliminar los dos valores m\'as altos y los dos valores m\'as bajos, recalculamos obteniendo los siguientes datos: \\
	\textbf{Esperanza}: 62.869,16667(ASM) y 1.087.346,333(C)\\
	\textbf{Desvío est\'andar}:	9.719,205547(ASM) y 145.528,2027(C)\\

	Se puede ver que al eliminar los outliers, el valor de la esperanza aumenta en ambos casos. Al haber hecho una medici\'on tan peque\~na, los c\'alculos de la esperanza no son tan estables y no son los m\'as ``parecidos'' a la realidad. Lo que s\'i ocurre es que al eliminar los valores mas alejados del promedio, como era de esperar, disminuye la desviaci\'on est\'andar al haber dejado s\'olo las mediciones m\'as cercanas entre s\'i.\\

\begin{figure}[h!]
  \begin{center}
	\includegraphics[width=0.7\textwidth]{imagenes/13/asm1.jpg}
	\caption{Assembler}
      \end{center}
\end{figure}

\newpage 
\begin{figure}[h!]
  \begin{center}
%	\label{nombreparareferenciar}
	\includegraphics[width=0.7\textwidth]{imagenes/13/C1.jpg}
	\caption{C}
  \end{center}
\end{figure}

\textcolor{red}{Volver a hacer los graficos con los valores que quedaron!!!!!!!}\\
\indent Siendo el Caso 1 las mediciones de esperanza y Desvío est\'andar para todos los casos de test y el Caso 2 las mediciones sin tener en cuenta los cuatro outliers.\\

\bigskip
    \item Implementar un programa en C que no haga más que ciclar infinitamente sumando 1 a una variable. Lanzar este programa tantas veces como \emph{cores lógicos} tenga su procesador. Medir otras 10 veces mientras estos programas corren de fondo. Realizar los mismos casos de experimentaci\'on que en el ejercicio anterior.\\
\end{enumerate}
Los resultados obtenidos en esta experimentaci\'on fueron menores que los anteriores: \\
\\       
        \begin{tabular}[c]{|c|c|c|}
	\hline
		\textbf{ASM} & \textbf{C}\\
		\hline
33.585 &	542.928 \\
\hline
33.798 &	544.155 \\
\hline
33.402 &	544.857 \\
\hline
33.228 &	543.687 \\
\hline
33.159 &	543.252 \\
\hline
33.441 &	543.324 \\
\hline
34.089 &	544.224 \\ 
\hline
33.768 &	760.359 \\ 
\hline
34.563 &	542.448 \\
\hline
34.473 &	542.982 \\
\hline
		\textbf{Esperanza}	\\
		\hline
33.750,6 & 565.221,6	\\		
		\hline
		\textbf{Desvío est\'andar}	\\
		\hline
465,49 & 65.049,34\\
		\hline
	\end{tabular}\\\\
	Luego de eliminar los dos valores m\'as altos y los dos valores m\'as bajos, recalculamos obteniendo los siguientes datos: \\
	\textbf{Esperanza}: 33.680,5 (ASM) y 543.604(C)\\
	\textbf{Desvío est\'andar}:	235,364 (ASM) y 462,615(C)\\
	Ac\'a tambi\'en se puede apreciar que al eliminar los outliers, el Desvío est\'andar disminuye su valor. \\

Se puede observar que las mediciones mejoran con la ejecuci\'on del ciclo infinito de fondo, esto se debe a que fue ejecutado en una computadora con un procesador i5. \textcolor{red}{Podria explicarse un poco mas que pasa con los is}\\
\\
\indent Por este motivo, volvimos a ejecutar este caso una mayor cantidad de veces para que el procesador no modifique la frecuencia de clock, obteniendo los siguientes resultados: \\
\textbf{Esperanza:} 269.945,590 (ASM) y 9.524.152,001 (C) \\
\textbf{Desv\'io est\'andar:} 3.801,837 y 7.774.736,417 (C) \\
\textcolor{red}{Hacer el grafico de este.}\\
\bigskip

\textit{A partir de aquí todos los experimentos de mediciones deberán hacerse igual 
que en el presente ejercicio: tomando 10 mediciones, luego descartando 
outliers y finalmente calculando promedio y Desvío est\'andar.}\\
\\
Decidimos: \\

Realizar 12000 mediciones por experimento, eliminando los primeros dos mil quinientos casos que hayan llevado menos ciclos de clock y los dos mil quinientos casos que hayan llevado la mayor cantidad de ciclos de clock. 

Lo determinamos de esta manera, ya que dejar dos mediciones afuera, como dice el enunciado, no tiene influencia en los c\'alculos de la esperanza y la varianza para muestras tan grandes. 

Luego de experimentar distintas cantidades de casos de testeo, notamos que elegir 7000 valores pertenecientes a la franja del medio de los 12000 es una soluci\'on lo suficientemente estable, por lo cual es la que llevamos a cabo. \\
\\
% ******************************************************************************
\newpage
\noindent\textbf{Experimento 1.4 - secuencial vs. vectorial}

En este experimento deberá realizar una medición de las diferencias de 
performance entre las versiones de C y ASM (el primero con -O0, -O1, -O2 y -O3) 
y graficar los resultados. \\
\\
El siguiente gr\'afico indica la esperanza de la cantidad de ciclos de clock que toma ejecutar el filtro Cropflip con los par\'ametros 404 404 4 4 en ASM y en C variando los flags de o0 a o3. \\
Reflejando las siguientes magnitudes: \\
\\
 \begin{tabular}[c]{|c|c|c|}
	\hline
		 & Esperanza & Desv\'io est\'andar\\
		\hline
C -o0 & 6.761.044,5 & 131,463 \\
\hline
C -o1 & 1.300.109 & 53,447 \\
\hline
C -o2 & 1.227.102,5 & 50,143\\
\hline
C -o3 & 266.688 & 0,287 \\
\hline
ASM & 362.232 & 2,079\\
\hline
	\end{tabular}\\\\


Se puede observar que la varianza es casi despreciable considerando el valor de la esperanza. Adem\'as, es notorio c\'omo el correr el programa con la orden de -o0 no efect\'ua ninguna optimizaci\'on. Tambi\'en se puede observar que el c\'odigo corrido en C bajo el comando de -o3 tiene una esperanza menor a la del c\'odigo Assembler. \textcolor{red}{Esto se debe a que el flag de optimizaci\'on -o3 lo que hace es blablablaba y por eso es una buena optimizaci\'on para el c\'odigo.}


\begin{figure}[h!]
  \begin{center}
	\includegraphics[width=0.7\textwidth]{imagenes/14.jpg}
  \end{center}
\end{figure}
\newpage

% ******************************************************************************
\vspace*{0.3cm} \noindent
\textbf{Experimento 1.5 - cpu vs. bus de memoria}

Se desea conocer cual es el mayor limitante a la
performance de este filtro en su versión ASM.

¿Cuál es el factor que limita la performance en este caso?
En caso de que el limitante fuera la intensidad de cómputo, entonces 
podrían agregarse instrucciones que realicen accesos a memoria extra y la
performance casi no debería sufrir. 
La inversa puede aplicarse, si el limitante es la cantidad de accesos a memoria.
\footnote{también podría pasar que estén más bien balanceados y que agregar
cualquier tipo de instrucción afecte sensiblemente la performance}
	
Realizar un experimento, agregando 4, 8 y 16 instrucciones aritméticas 
(por ej \verb|add rax, rbx|) analizando como varía el tiempo de ejecución.
Hacer lo mismo ahora con instrucciones de acceso a memoria, haciendo 
mitad lecturas y mitad escrituras (por ejemplo, agregando dos 
\verb|mov rax, [rsp]| y dos \verb|mov [rsp+8], rax|).\footnote{Notar que en el caso de acceder a \texttt{[rbp]} o \texttt{[rsp+8]} probablemente haya siempre hits en la cache, por lo que la medición no será de buena calidad. Si se le ocurre la manera, realizar accesos a otras direcciones alternativas.}
	
Realizar un único gráfico que compare:
\begin{inparaenum}
    \item La versión original
    \item Las versiones con más instrucciones aritméticas
    \item Las versiones com más accesos a memoria
\end{inparaenum}
\\
Acompañar al gráfico con una tabla que indique los valores graficados. \\
\\
\textcolor{red}{Las instrucciones aritm\'eticas usadas son: BLA BLA BLA repetidas la cantidad de veces necesitada y los accesos a memoria realizados fueron: BLA BLA BLA.}\\
\\
 \begin{tabular}[c]{|c|c|c|}
	\hline
		Cropflip & Esperanza & Desv\'io est\'andar\\
		\hline
Versi\'on com\'un & 157.236,897 & 5.334,414 \\
\hline
Con 4 instrucciones aritméticas & 183.968,425 & 8.391,506 \\
\hline
Con 8 instrucciones aritméticas & 225.991,244 & 7.729,428 \\
\hline
Con 16 instrucciones aritméticas & 707.857,067 & 12.756,322 \\
\hline
Con 4 accesos a memoria & 281.032,176 & 11.258,907 \\
\hline
Con 8 accesos a memoria & 352.370,777 & 14.353,789 \\
\hline
Con 16 accesos a memoria & 342.023,334 & 12.136,799 \\
\hline
	\end{tabular}\\\\
\\

\begin{figure}[h!]
  \begin{center}
%	\includegraphics[width=0.7\textwidth]{imagenes/15.jpg}
 \textcolor{red}{volver a hacer el gr\'afico.'}
  \end{center}
\end{figure}
\textcolor{red}{Con 4 y 8 accesos a memoria, el programa es m\'as lento. Con 16 accesos pasa algo no intuitivo, que al menos deber\'ia mencionarse. El pico de 16 instrucciones aritm\'eticas tampoco me resulta intuitivo a simple vista.}

% ------------------------------------------------------------------------------
  \newpage
\subsection{Filtro \textit{Sierpinski}}

Programar el filtro \textit{Sierpinski} en lenguaje C y en en ASM haciendo 
uso de las instrucciones vectoriales (\textbf{SSE}).

% ******************************************************************************
\vspace*{0.3cm} \noindent
\textbf{Experimento 2.1 - secuencial vs. vectorial}

Analizar cuales son las diferencias de performace entre las versiones de C 
y ASM de este filtro, de igual modo que para el experimento 1.4. \\
\\
El gr\'afico a continuaci\'on indica la esperanza y el desv\'io est\'andar de la cantidad de ciclos de clock que toma ejecutar el filtro Sierpinski en ASM y en C variando los flags de o0 a o3. \\
Reflejando las siguientes magnitudes: \\
\\
 \begin{tabular}[c]{|c|c|c|}
	\hline
		 & Esperanza & Desv\'io est\'andar\\
		\hline
C -o0 & 28.801.586,5 & 78,016 \\
\hline
C -o1 & 21.395.732 & 78,447 \\
\hline
C -o2 & 14.231.758 & 116,445 \\
\hline
C -o3 & 14.229.650 & 116,022 \\
\hline
ASM & 3.661.626 & 115,583 \\
\hline
	\end{tabular}\\\\
\\

\begin{figure}[h!]
  \begin{center}
	\includegraphics[width=0.7\textwidth]{imagenes/21.jpg}
  \end{center}
\end{figure}

Aqu\'i tambi\'en el valor del desv\'io est\'andar es despreciable. Donde correr el c\'odigo en C bajo el comando -o0 sigue siendo el caso con mayor esperanza (peor caso) y adem\'as la esperanza del c\'odigo Assembler es menor a la del c\'odigo C con -o3. Las optimizaciones -o2 y -o3 arrojan resultados similares, ambos por encima de los valores en ASM. En este caso, notablemente es m\'as eficaz el filtro programado en Assembler.



% ******************************************************************************
\newpage
\vspace*{0.3cm} \noindent
\textbf{Experimento 2.1 - cpu vs. bus de memoria}

¿Cuál es el factor que limita la performance en este filtro?
Repetir el experimento 1.5 para este filtro. \\

Las instrucciones utilizadas son las mismas que en el caso anterior, lo mismo con los accesos a memoria.\\
\\
 \begin{tabular}[c]{|c|c|c|}
	\hline
		 & Esperanza & Desv\'io est\'andar\\
		\hline
Versi\'on com\'un & 2.936.302,152 & 26.416,331 \\
\hline
Con 4 instrucciones aritméticas & 2.961.773,596 & 47.749,307 \\
\hline
Con 8 instrucciones aritméticas & 2.940.553,343 & 59.912,727 \\
\hline
Con 16 instrucciones aritméticas & 3.031.280,298 & 37.499,415 \\
\hline
Con 4 accesos a memoria & 2.919.253,679 & 57.697,386 \\
\hline
Con 8 accesos a memoria & 2.936.432,138 & 56.870,171 \\
\hline
Con 16 accesos a memoria & 3.051.926,505 & 40.964,812 \\
\hline
	\end{tabular}\\\\


\begin{figure}[h!]
  \begin{center}
%	\includegraphics[width=0.7\textwidth]{imagenes/21B.jpg}
\textcolor{red}{Aca tambien falta el grafico!}
  \end{center}
\end{figure}

En este caso, los accesos a memoria influyen m\'as notoriamente en la esperanza que las operaciones aritm\'eticas l\'ogicas. En este caso, se observa un desv\'io est\'andar elevado teniendo en cuenta el tama\~no de las mediciones.\\

\textcolor{red}{Algo parecido al experimento 1.5 \\
Adem\'as se podr\'ia mencionar que el desv\'io est\'andar es elevado.}


\newpage

\subsection{Filtro \textit{Bandas}}

Programar el filtro \textit{Bandas} en lenguaje C y en en ASM haciendo uso de 
las instrucciones vectoriales (\textbf{SSE}).

% ******************************************************************************
\vspace*{0.3cm} \noindent
\textbf{Experimento 3.1 - saltos condicionales}

Se desea conocer que tanto impactan los saltos condicionales en el código 
de filtro Bandas con \verb|-O1| (la versión en C).\\
Para poder medir esto de manera aproximada, remover el código
que detecta a que banda pertenece cada pixel, dejando
sólo una banda.
Por más que la imagen resultante no sea correcta, será posible tomar una
medida aproximada del impacto de los saltos condicionales.
Analizar como varía la performance. \\
\\
En la siguiente figura se ve c\'omo var\'ia la esperanza y el desv\'io est\'andar entre dos corridas de C con el flag -o1 ambas:

\begin{figure}[h!]
  \begin{center}
	%\includegraphics[width=0.7\textwidth]{imagenes/31.jpg}
    \textcolor{red}{Aca tambien me borraron el grafico!!!!!}
  \end{center}
\end{figure}

En el gr\'afico anterior se puede ver que la influencia de los saltos condicionales es notable. \\

\bigskip
% ******************************************************************************
\vspace*{0.3cm} \noindent
\textbf{Experimento 3.2 - secuencial vs. vectorial}

Repetir el experimento 1.4 para este filtro. \\
\\
El siguiente gr\'afico indica la esperanza de la cantidad de ciclos de clock que toma ejecutar el filtro Bandas en ASM y en C variando los flags de o0 a o3. \\
Reflejando las siguientes magnitudes: \\
\\
 \begin{tabular}[c]{|c|c|c|}
	\hline
		 & Esperanza & Desv\'io est\'andar\\
		\hline
C -o0 & 17.472.791 & 120,620 \\
\hline
C -o1 & 4.583.340 & 128,514 \\
\hline
C -o2 & 3.259.839 & 117,746 \\
\hline
C -o3 & 3.259.767 & 117,391  \\
\hline
ASM & 3.703.203,5 & 115,659 \\
\hline
	\end{tabular}\\\\

Aqu\'i tambi\'en el valor del desv\'io est\'andar es despreciable. En este caso, el tiempo de ejecuci\'on del c\'odigo con el comando de -o3 tiene una esperanza menor a la del c\'odigo Assembler. \textcolor{red}{y -o2 tambien, por que?}

\begin{figure}[h!]
  \begin{center}
	\includegraphics[width=0.7\textwidth]{imagenes/32.jpg}
  \end{center}
\end{figure}


% ------------------------------------------------------------------------------
\newpage
\subsection{Filtro \textit{Motion Blur}}
Programar el filtro \textit{mblur} en lenguaje C y en ASM haciendo uso de 
las instrucciones \textbf{SSE}.

% ******************************************************************************
\vspace*{0.3cm} \noindent
\textbf{Experimento 4.1}

Repetir el experimento 1.4 para este filtro \\
\\
El siguiente gr\'afico indica la esperanza de la cantidad de ciclos de clock que toma ejecutar el filtro Bandas en ASM y en C variando los flags de o0 a o3. \\
Reflejando las siguientes magnitudes: \\
\\
 \begin{tabular}[c]{|c|c|c|}
	\hline
		 & Esperanza & Desv\'io est\'andar\\
		\hline
C -o0 & 24.652.732,5 & 117,738 \\
\hline
C -o1 & 11.562.261 & 103,024  \\
\hline
C -o2 & 9.641.346 & 78,159  \\
\hline
C -o3 & 9.639.625 & 78,227 \\
\hline
ASM & 2.993.980,5 & 118,245 \\
\hline
	\end{tabular}\\\\
\\
Aqu\'i tambi\'en el valor del desv\'io est\'andar es despreciable. Donde las optimizaciones del compilador en la versi\'on -o3 y la versi\'on -o2' no son suficientes para tener una esperanza menor a la esperanza obtenida bajo el c\'odigo Assembler.\\
\newpage
\begin{figure}
  \begin{center}
	\includegraphics[width=0.7\textwidth]{imagenes/41.jpg}
  \end{center}
\end{figure}
\newpage