\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
%\usepackage{makeidx}
\usepackage{paralist} %itemize inline

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}


\input{codesnippet}
\input{page.layout}
% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}


% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %



\begin{document}


\thispagestyle{empty}
\materia{Organización del Computador II}
\submateria{Segundo Cuatrimestre de 2014}
\titulo{Trabajo Práctico II}
\subtitulo{Programaci\'on SIMD}
\integrante{Agustina Aldasoro}{86/13}{agusaldasoro@gmail.com}
\integrante{Maximiliano Rey}{37/13}{rey.maximiliano@gmail.com}
\integrante{Ignacio Tirabasso}{718/12}{ignacio.tirabasso@gmail.com}

\maketitle
\newpage

\thispagestyle{empty}
\vfill
\begin{abstract}
En el presente trabajo se describen los beneficios de la programaci\'on en Lenguaje Ensamblador bajo el modelo de programaci\'on SIMD mediante el uso de instrucciones SSE.
\end{abstract}


\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage


%\normalsize
\newpage

\section{Objetivos generales}

El objetivo de este Trabajo Práctico es evaluar la eficiencia del modelo de programaci\'on SIMD mediante la implementaci\'on de diversos algoritmos en lenguaje Ensamblador utilizando instrucciones SSE. \\
\indent Las mediciones se realizan mediante pruebas emp\'iricas del c\'odigo frente a algoritmos que cumplen la misma especificaci\'on, implementados en un lenguaje de alto nivel (C). \\
\indent En este proyecto, los algoritmos a implementar se basaron en el procesamiento de im\'agenes y video, en el cual el uso del modelo SIMD es provechoso.


\section{Contexto}

Abordando el objetivo de este trabajo, realizamos una experimentaci\'on enfocada en reducir el tiempo de c\'omputo de un programa basado en dos sucesos que tienen la capacidad de afectarlo. \\
\indent Por un lado se encuentra la \textit{capacidad de c\'omputo}, la cual limita la cantidad de operaciones aritm\'eticas que el procesador puede paralelizar. Si el programa ejecuta un uso intensivo en operaciones aritm\'eticas, al añadirle nuevas operaciones de esta \'indole se van a necesitar m\'as ciclos de clock para ejecutarlas. \\
\indent El otro cuello de botella importante es el \textit{ancho de banda de la memoria}. Cuando el programa ejecuta una instrucci\'on que implica un acceso a memoria, se precisan m\'as ciclos de clock para que la memoria responda, en particular si el dato no se encuentra en el cache.\\
\indent Diseñamos nuestros casos de testeo con el fin de observar para cada programa cu\'al es el factor que determina el tiempo de c\'omputo.\\
\\
\indent Nuestra experimentaci\'on se centra en la cantidad de ciclos de clock que transcurren desde el inicio hasta el final de la ejecuci\'on del programa. Se adjunta con la documentaci\'on los archivos *.py utilizados para calcular la esperanza y la varianza de cada una de las mediciones.\\
\\
\textcolor{red}{Si lo vamos a rearmar, habria que explicar un poquito mas que hace el codigo, cuantas iteraciones y que descarta los maximos y minimos}\\

%\begin{figure}
%  \begin{center}
%	\includegraphics[scale=0.66]{imagenes/logouba.jpg}
%	\caption{Descripcion de la figura}
%	\label{nombreparareferenciar}
%  \end{center}
%\end{figure}


%\paragraph{\textbf{Titulo del parrafo} } Bla bla bla bla.
%Esto se muestra en la figura~\ref{nombreparareferenciar}.
%\begin{codesnippet}
%\begin{verbatim}
%
%struct Pepe {
%
%    ...
%
%};
%\end{verbatim}
%\end{codesnippet}
\newpage
\section{Implementaci\'on en Assembler}

\subsection{Filtro CropFlip}
%\begin{codesnippet}
%\begin{verbatim}
\indent Luego de pushear los cinco registros a utilizar, almacenamos: \\
\begin{codesnippet}
\begin{verbatim}
Pushear la base de la pila y los registros a utilizar.
Alinear la pila.
mov r12d, [rbp+16] ;tamx
mov r13d, [rbp+24] ;tamy
mov r14d, [rbp+32] ;offsetx
mov r15d, [rbp+40] ;offsety
Limpiamos la parte alta de estos registros haciendo un mov rXd, rXd.
\end{verbatim}
\end{codesnippet}

 \indent Utilizamos el registro \textbf{r10} como el \emph{y-actual} (fuente) y el registro \textbf{r11} como el \emph{x-actual} (fuente). Recorremos la imagen fuente desde arriba hacia abajo, de izquierda a derecha.\\
 \begin{codesnippet}
\begin{verbatim}
	mov r10,r15 ; y
	mov r11,r14 ; x
\end{verbatim}
\end{codesnippet}
 \indent Utilizamos el registro \textbf{rcx} como el \emph{y$_2$-actual} (destino) y el registro \textbf{rdx} como el \emph{x$_2$-actual} (destino). Recorremos la imagen destino de abajo hacia arriba, de izquierda a derecha. Al registro rcx debemos decrementarlo en uno porque arranca inicializado en cero. \\
 \begin{codesnippet}
\begin{verbatim}
mov rcx,r13 ; y2 = tamy
dec rcx     ; y2 = tamy-1
mov rdx,0   ; x2 = 0
\end{verbatim}
\end{codesnippet}

\indent En \textbf{r13} almacenamos el l\'imite para r10, es decir tiene que recorrer el ciclo de y hasta que alcance su l\'imite en y (offsety+tamy). \\
	  \begin{codesnippet}
\begin{verbatim}
	add r13,r15 ; r13 = offsety+tamy
\end{verbatim}
\end{codesnippet}
\indent En \textbf{rbx} almacenamos el l\'imite para r11, es decir tiene que recorrer el ciclo de x hasta que alcance su l\'imite en x (offsetx+tamx)\\
	  \begin{codesnippet}
\begin{verbatim}
mov rbx,r12  ; rbx = tamx
	add rbx,r14  ; rbx = offsetx+tamx
\end{verbatim}
\end{codesnippet}

\indent Ahora comienza el ciclo de iteraci\'on sobre la variable \emph{y}. Cada vez que se ejecuta se comprueba que el \emph{y-actual} (\textbf{r10}) sea menor que su l\'imite (\textbf{r13}). Y por cada iteraci\'on se reinician los valores de \emph{x} e \emph{x$_2$} a la primer columna que debemos trabajar (Para la imagen fuente es el offset inicial de la variable \emph{x}, para la imagen destino es el \emph{0}).
	  \begin{codesnippet}
\begin{verbatim}
.loop_y:
	cmp r10,r13     ; y < offsety+tamy
	jge .endloop_y
	mov r11,r14     ; x = offsetx
	mov rdx,0       ; x2 = 0
\end{verbatim}
\end{codesnippet}

\indent Por consiguiente, para cada valor que vaya tomando la variable, se debe ejecutar un ciclo para poder iterar sobre todas las columnas (Ciclo de x). Por cada iteraci\'on, se compara si el \emph{x-actual} (\textbf{r11}) es menor que su l\'imite (\textbf{rbx}). Si no lo es, se salta fuera del ciclo de x. \\
\indent Luego, comienza a ejecutar el c\'odigo propio del ciclo. Es necesario tener en cuenta que: \\
$\star$ En \textbf{r8} est\'a cargado el \textit{row_size} de la imagen fuente. \\
$\star$ En \textbf{r9} est\'a cargado el \textit{row_size} de la imagen de destino. \\
\indent Vamos a calcular en cada iteraci\'on la cantidad de posiciones en memoria (bytes) que se le deben sumar a la posici\'on de origen de la imagen para encontrarnos en la posici\'on actual. Esto se almacena en el registro \textbf{rax}. Primero copiamos el contenido de \textbf{r10} (\emph{y-actual}), lo multiplicamos por el largo de cada fila para as\'i posicionarnos en la fila actual y por \'ultimo le sumamos \textbf{r11} (que indica el n\'umero de fila actual) multiplicado por 4 porque cada Pixel tiene 4 bytes. De este modo, \textbf{rax} contiene el offset que debemos sumarle a la posici\'on en memoria de la imagen fuente para situarnos en la posici\'on actual.\\
\indent Como nos encontramos utilizando registros Xmm, vamos a trabajar con 4 pixels a la vez, de modo que entran en un solo registro. Para levantar de memoria 4 pixels, utilizamos la intrucci\'on \textit{movdqu}. \\
\indent Por \'ultimo, lo que tenemos que hacer es guardar esos 4 pixels levantados con el mismo orden en la posici\'on correspondiente de la imagen destino. Es decir, la misma columna \emph{x} pero sin su offset (por eso mismo se usan dos registros distintos, ya que el offset de la imagen de destino es 0) y la fila \emph{y$_2$} va a ser la diferencia entre la cantidad de filas e \emph{y}. \\
\indent An\'alogamente a lo anterior, en \textbf{rax} se guarda el offset de la imagen destino, para acceder a memoria sum\'andoselo a la posici\'on donde esta almacenada la imagen. \\
\indent Se suma 4 a las variables r11(\emph{x-actual}) y rdx(\emph{x$_2$-actual}), porque en este paso avanzamos 4 pixels. Y el jump se ejecuta siempre, ya que la comparaci\'on se produce al principio del ciclo.
	  \begin{codesnippet}
\begin{verbatim}
.loop_x:

	cmp r11,rbx      ; x < offsetx+tamx
	jge .endloop_x

	mov rax,r10
	imul rax,r8
	lea rax,[rax+r11*4]

	movdqu xmm0,[rdi+rax]

	mov rax,rcx
	imul rax,r9
	lea rax,[rax+rdx*4]

	movdqu [rsi+rax],xmm0

	add r11,4
	add rdx,4
	jmp .loop_x	
\end{verbatim}
\end{codesnippet}

\indent Una vez copiada toda una fila, debemos avanzar hacia la siguiente. De este modo: incrementamos en uno r10(\emph{y-actual}) y rcx(\emph{y$_2$-actual}). \\
\indent Se ejecuta siempre un jump hacia el comienzo del ciclo en y, porque la comparaci\'on de ver si ya copiamos todas las filas se ejecuta al principio.
	  \begin{codesnippet}
\begin{verbatim}
.endloop_x:
	inc r10
	dec rcx
	jmp .loop_y
\end{verbatim}
\end{codesnippet}

\indent Una vez terminado el ciclo de y, s\'olo resta salir de la ejecuci\'on respetando la convenci\'on C.
	  \begin{codesnippet}
\begin{verbatim}
.endloop_y:
 Alinear la pila y popear todos los registros.
 ret
\end{verbatim}
\end{codesnippet}

\newpage
\subsection{Filtro Sierpinsky}
Hola
\newpage
\subsection{Filtro Bandas}
Hola
\newpage
\subsection{Filtro Motion Blur}
\indent Primero hacemos algunos define que vamos a necesitar luego:
 \begin{codesnippet}
\begin{verbatim}
cerocomados  dd  0.2 , 0.2 , 0.2 , 0.2
rgb_only     dd  0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF, 0x00FFFFFF
\end{verbatim}
\end{codesnippet}

 \begin{codesnippet}
\begin{verbatim}
Salvamos la base de la pila y los registros a utilizar. Alineamos la pila.
Limpiamos con xor o pxor los registros a utilizar: r10, r11, r15, r13 y xmm13.

; r10 = i
; r11 = j
mov r15d,edx ; r15 = cols
	mov r14d,ecx ; r14 = filas
	sub r15,2 	 ; r15 = cols -2 
	sub r14,2 	 ; r14 = filas - 2 
\end{verbatim}
\end{codesnippet}

\indent El registro xmm13 es limpiado para luego utilizarlo a la hora de asignarle el borde negro. Se les resta 2 a las filas y a las columnas porque los \'ultimos dos p\'ixeles del borde van de negro.\\
\\
\indent Comienza el ciclo de y, es decir, primero recorremos por filas y por cada fila recorremos por columnas. Se recorren todas las filas y cada vez que se entra en el loop_x se inicializa la fila en cero.
 \begin{codesnippet}
\begin{verbatim}
.loop_y:
    cmp r10d,ecx 	; i < filas 
    jge .endloop_y
	
    mov r11,0 		; j = 0
\end{verbatim}
\end{codesnippet}

\indent El loop_x se recorre hasta que j alcanza el valor de la \'ultima columna. En el registro \textbf{rax} vamos a asignarle el n\'umero de orden del byte a tratar, es decir la fila actual multiplicada por la cantidad de columnas sumado a la columna actual multiplicada por cuatro porque es lo que ocupa un p\'ixel. 
Antes de asignarle el nuevo valor a la imagen, debemos comprobar si el p\'ixel a tratar es de borde (el cual queda en negro: .cero) o si no lo es (.nocero). Todos los p\'ixeles que son bordes son los que est\'an ubicados en las primeras dos filas o columnas y los que est\'an ubicados en las \'ultimas dos filas o columnas.
 \begin{codesnippet}
\begin{verbatim}
.loop_x:
    cmp r11d,edx ; j < cols 
    jge .endloop_x

    mov rax,r10  ; rax = i
    imul eax,r8d ; rax = i * row_size 
    lea rax,[rax+r11*4] ; rax = i * row_size + j * 4

    cmp r11,2   
    jl .cero    ; j < 2
    cmp r10,2 
    jl .cero    ; i < 2
    cmp r10,r14
    jge .cero   ; i >= cols -2
    cmp r11,r15
    jge .cero   ; j >= filas -2

    jmp .nocero
\end{verbatim}
\end{codesnippet}

\newpage
\indent Si el p\'ixel a tratar debe quedar en negro (cero) lo que debemos hacer es asignarle ceros mediante el registro \textbf{xmm13}:
 \begin{codesnippet}
\begin{verbatim}
.cero:
    movq [rsi+rax],xmm13        
    add r11,2
    jmp .loop_x
\end{verbatim}
\end{codesnippet}

A continuaci\'on comienza la rutina a llevar a cabo en caso de que el p\'ixel a tratar no sea borde. Se copia en \textbf{rbx} el puntero actual con el que vamos a trabajar. Recordar que en \textbf{rax} ten\'iamos el offset en la imagen y en \textbf{rdi} el puntero al comienzo de la misma. Vamos a ejecutar 4 p\'ixeles por vez (porque son los que entran en un registro xmm) y para ello necesitamos hacer cinco lecturas a memoria y as\'i tener para cada p\'ixel sus cuatro vecinos que van a influir en su valor final. En \textbf{xmm14} copiamos el contenido de \textit{rgb_only} el cual nos permitir\'a s\'olo trabajar con los canales RGB de cada p\'ixel m\'as adelante.
 \begin{codesnippet}
\begin{verbatim}
.nocero:
    
    lea rbx,[rdi+rax]
    movdqu xmm1,[rbx]        ; (i,j)
    movdqu xmm2,[rbx+r8*1+4] ; (i+1,j+1)
    movdqu xmm3,[rbx+r8*2+8] ; (i+2,j+2)
    mov r12,rbx
    sub r12,r8
    movdqu xmm4,[r12-4]      ; (i-1,j-1)
    sub r12,r8
    movdqu xmm5,[r12-8]      ; (i-2,j-1)

    movdqu xmm14,[rgb_only]
\end{verbatim}
\end{codesnippet}


 \begin{codesnippet}
\begin{verbatim}
    pxor xmm0,xmm0
    movdqu xmm6,xmm1
    punpcklbw xmm1,xmm0 
    punpckhbw xmm6,xmm0

    movdqu xmm7,xmm2
    punpcklbw xmm2,xmm0
    punpckhbw xmm7,xmm0

    movdqu xmm8,xmm3
    punpcklbw xmm3,xmm0
    punpckhbw xmm8,xmm0

    movdqu xmm9,xmm4
    punpcklbw xmm4,xmm0
    punpckhbw xmm9,xmm0

    movdqu xmm10,xmm5
    punpcklbw xmm5,xmm0
    punpckhbw xmm10,xmm0

    paddw xmm1,xmm2
    paddw xmm1,xmm3
    paddw xmm1,xmm4
    paddw xmm1,xmm5

    paddw xmm6,xmm7
    paddw xmm6,xmm8
    paddw xmm6,xmm9
    paddw xmm6,xmm10

    movdqu xmm2,xmm1
    movdqu xmm7,xmm6

    punpcklwd xmm1,xmm0
    punpckhwd xmm2,xmm0

    punpcklwd xmm6,xmm0
    punpckhwd xmm7,xmm0

    cvtdq2ps xmm1,xmm1  
    cvtdq2ps xmm2,xmm2  
    cvtdq2ps xmm6,xmm6  
    cvtdq2ps xmm7,xmm7

    movdqu xmm15,[cerocomados]

    mulps xmm1,xmm15
    mulps xmm2,xmm15
    mulps xmm6,xmm15
    mulps xmm7,xmm15

    cvtps2dq xmm1,xmm1
    cvtps2dq xmm2,xmm2
    cvtps2dq xmm6,xmm6
    cvtps2dq xmm7,xmm7

    packusdw xmm1,xmm2
    packusdw xmm6,xmm7

    packuswb xmm1,xmm6

    movdqu [rsi+rax],xmm1   

    add r11,4
    jmp .loop_x

\end{verbatim}
\end{codesnippet}


\newpage
\section{Enunciado y soluci\'on} 

\input{enunciado}

\section{Conclusiones y trabajo futuro}
\indent\emph{ \textcolor{red}{Si bien un lenguaje ensamblador solo es utilizable en determinada gama de procesadores (ESTO HAY QUE SACARLO DIJO MATIAS)}}, los resultados de nuestras mediciones han demostrado que la implementación de los filtros en este lenguaje han logrado una performance que el gcc no logro conseguir. \\
\indent Dada la popularidad de la arquitectura de 64 bits de intel, se puede concluir que la implementación del SIMD en assembler tiene un precio razonable frente a la perfomance alcanzada.\\


\end{document}

